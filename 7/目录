前言
第1章  文件结构
1.1  版权和版本的声明
1.2  头文件的结构
1.3  定义文件的结构
1.4  头文件的作用
1.5  目录结构

第2章  程序的版式
2.1  空行
2.2  代码行
2.3  代码行内的空格
2.4  对齐
2.5  长行拆分
2.6  修饰符的位置
2.7  注释
2.8  类的版式

第3章  命名规则
3.1  共性规则
3.2  简单的Windows应用程序命名规则
3.3  简单的Unix应用程序命名规则

第4章  表达式和基本语句
4.1  运算符的优先级
4.2  复合表达式
4.3  IF语句
4.4  循环语句的效率
4.5  FOR语句的循环控制变量
4.6  SWITCH语句
4.7  GOTO语句

第5章  常量
5.1  为什么需要常量
5.2  CONST与#DEFINE的比较
5.3  常量定义规则
5.4  类中的常量

第6章  函数设计
6.1  参数的规则
6.2  返回值的规则
6.3  函数内部实现的规则
6.4  其他建议
6.5  使用断言
6.6  引用与指针的比较

第7章  内存管理
7.1  内存分配方式
7.2  常见的内存错误及其对策
7.3  指针与数组的对比
7.4  指针参数是如何传递内存的？
7.5  FREE和DELETE把指针怎么啦？
7.6  动态内存会被自动释放吗？
7.7  杜绝“野指针”
7.8  有了MALLOC/FREE为什么还要NEW/DELETE？ 
7.9  内存耗尽怎么办？
7.10 MALLOC/FREE的使用要点
7.11 NEW/DELETE的使用要点
7.12 一些心得体会

第8章  C++函数的高级特性
8.1  函数重载的概念
8.2  成员函数的重载、覆盖与隐藏
8.3  参数的缺省值
8.4  运算符的重载
8.5  函数内联
8.6  一些心得体会

第9章 类的构造函数、析构函数与赋值函数
9.1  构造函数与析构函数的起源
9.2  构造函数的初始化表
9.3  构造和析构的次序
9.4  示例：类STRING的构造函数与析构函数
9.5  不要轻视拷贝构造函数与赋值函数
9.6  示例：类STRING的拷贝构造函数与赋值函数
9.7  偷懒的办法处理拷贝构造函数与赋值函数
9.8  如何在派生类中实现类的基本函数
9.9  一些心得体会

第10章  类的继承与组合
10.1  继承
10.2  组合

第11章  其他编程经验
11.1  使用CONST提高函数的健壮性
11.2  提高程序的效率
11.3  一些有益的建议

参考文献
附录A：C++/C代码审查表
附录B：C++/C试题
附录C：C++/C试题的答案与评分标准
