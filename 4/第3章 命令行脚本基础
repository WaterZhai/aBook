第3章   命令行脚本基础

在图形用户界面占统治地位的IT世界，命令行脚本会提供哪些点选式对话框所不能提供的功能？实事求是地说，命令行脚本所能提供的功能要比大多数人所知道的多--对大部分把命令行脚本看成美化与增强版的批处理文件（那种在8086处理器与MS-DOS环境中使用的文件）的人来说尤其如此。现今的命令行脚本环境是一个功能广泛的程序设计环境，包含如下一些要素：
· 变量
· 算术表达式
· 条件语句
· 控制流语句
· 过程
通过这些程序设计要素，你可以做到：自动执行一些重复性的任务、在远离计算机时执行复杂的操作、发现他人错误放置的资源、执行很多其他耗时甚久的任务（通常需要在键盘键入数据才能完成的）等。命令行脚本不仅具备对命令行的完全的访问权限，也可以调用带有命令行扩展的任意工具。

3.1创建命令行脚本
    命令行脚本是包含待执行命令的文本文件，这些命令与通常情况下在Windows命令shell中键入的命令是一样的，将命令存储在命令行脚本中国的好处是不再需要每次都键入命令，而是在需要的时候通过脚本很容易地执行命令。
    由于脚本中包含的是标准的文本字符，因此可以使用标准的文本编辑器进行创建和编辑，比如记事本。在脚本中输入命令时，需要注意的是，每一条命令，或者每一组需要一起执行的命令，都应该保存在脚本的单独一行中，以便确保命令的正确执行。完成脚本创建后，使用.bat或.cmd文件口占保存，这两种扩展对命令行脚本的处理与执行是一样的。比如，为创建一个脚本来显示系统名、Windows版本以及IP配置等信息，就可以在名为SysInfo.bat或SysInfo.cmd的脚本中输入如下3条命令：
    hostname
    ver
    ipconfig -all
    以上面的扩展名保存脚本后，就可以将其当做Windows工具一样执行：在命令shell中键入脚本名，之后按Enter键。命令shell会读入脚本文件，并逐一执行其中的命令，直至到达文件的尾部或遇到EXIT命令。对上面的示例脚本，执行后，命令行的输出信息与命令清单类似。
    ---
    观察上面的输出信息，你会发现，命令提示符与实际命令的显示方式与单独执行命令时的输出方式是一致的。之所以会出现这种情况，是因为在默认的处理模式执行脚本时，命令shell做了一些附加的幕后工作。首先，命令shell显示命令提示符。之后，命令shell从脚本中读入一行，显示该行文本，并对其进行解释和执行。如果到达脚本文件的尾部，或者读入exit命令，则停止执行，否则就重复这一读入、显示和解释执行的过程。
    在默认的处理模式中，命令回显是打开的，这有助于对兼备进行调试与故障排除。但对于经常使用的脚本，你可能并不需要这种显示模式。幸运的是，通过关闭命令回显，可以改变这种默认的显示模式，在3.2.3节将讲述这一问题。
3.2脚本的常见语句与命令
    到目前为止，本书主要讨论了一些命令及相关问题，但没有介绍什么是语句。尽管这些术语经常互换使用，但严格来讲，语句（statements）是指命令的关键字。比如rem语句，但有时候语句也可能是指一行代码，其中包含了该行上所有的命令文本。在有些程序设计语言中，如Java，每条语句必须以特定的字符（分号）作为终止符。在命令行脚本中，命令行并不寻找特定的终止符，而是寻找每行的结束标志。比如，在命令解释器读入下面任意字符时就终止：
    · 断行（比如按下Shift+Enter键）
    · 回车与断行（比如按Enter键）
    · 文件尾标志。
    前面已经讨论了如何创建脚本，下面讨论脚本中可以使用的常用语句与命令。
    · Cls。清楚控制台窗口，重置屏幕缓冲。
    · Rem。在脚本中创建注释。
    · Echo。在命令行中显示消息、关闭或打开命令回显。
    · @。以行为单位控制命令的回显方式。
    · Title。设置命令shell窗口的标题栏。
    · Color。设置命令shell窗口使用的文本色与背景色。
    3.2.1清除命令窗口
        在将脚本输出写入到命令shell窗口之前，对其进行清空是一个较好的做法。要做到这一点，可以使用cls命令。在命令行中键入cls，之后按Enter键。控制台窗口将清空，光标将定位到命令shell窗口的左上角，其后紧随着命令提示符，屏幕缓存中的所有其他文字也被清空。
        在前面给出的示例脚本中，也可以加入cls命令，如下所示：
        cls
        hostname
        ver
        ipconfig -all
    3.2.2位脚本添加注释
        可以使用rem语句为脚本添加注释，为保证监本的清晰易读，创建脚本时，应该为其添加如下一些注释信息：
        · 脚本的创建时间与最后修改时间
        · 脚本的创建者
        · 脚本的用途
        · 脚本创建者的联系方式
        · 脚本输出是否保存及其保存位置。
        通过上面这些脚本描述信息，不仅有助于其他系统管理员使用该脚本，也有助于脚本的创建者准确记忆脚本的用途。尤其在输个星期、乃至数个月之后，创建者本人也很可能对脚本的用途已经陌生了。命令清单中给出了一个脚本实例，其中包含了这些注释信息。
        ---
        在3.3节，将讲述如何把注释信息转化为自动帮助文档。现在，需要学习的是使用rem语句来完成如下任务。
        · 在脚本中插入解释性文字，比如，讲述某过程如何工作的文档。
        · 防止命令的执行，在命令行，插入rem可以对命令进行注释和屏蔽。
        · 隐藏某行命令的一部分，使其不再被解释执行。插入rem后，其后的部分将不再由命令shell进行解释和执行。
    3.2.3管理文字的显示方式与命令回显方式
        ECHO命令有两种用途：一种是向输出（命令shell或文本文件）中写入信息，一种是打开或关闭命令回显。通常，在脚本中执行命令时，命令及其结果输出会在控制台窗口中显示，这称为命令回显（command echoing）。
        要使用ECHO命令显示文字，可以输入echo，其后跟随要显示的文字，如下所示：
        echo The system host name is :
        hostname
        要使用ECHO命令控制命令的回显方式，可以根据需要键入echo off或echo on，如下所示:
        echo  off
        echo  The system host name is :
        hostname
        使用ECHO命令，结合输出重定向技术，可以把输出信息发送到文件，而不是命令shell，如下：
        echo off
        echo The system host name is： > current.txt
        hostname  >> current.txt
        要尝试关闭命令回显的情况，可以在命令shell中键入echo off，之后输入其他命令。你会发现，命令提示符将不再显示，而只能看到自己 键入控制台窗口中的命令以及输出信息。与命令shell中类似，在脚本中使用ECHO OFF命令也可以关闭命令回显与命令提示符。为脚本添加ECHO OFF命令后，命令shell窗口或输出文件就不会被输入的那些命令本身所混淆，在只关注命令的输出信息时，这样做是有益的。
        （提示  顺便说一句，如果想确定命令回显状态是关闭还是打开，可以键入ECHO命令。如果命令回显是打开状态，会看到消息“ECHO处于打开状态”；如果命令回显是关闭状态，则会看到消息“ECHO处于关闭状态”。在脚本中使用ECHO OFF时，你可能会有一点疑问：如果说ECHO OFF的作用是关闭命令回显，那怎样防止ECHOOFF命令本身的回显呢？不用担心，3.2.4节会讲解这个问题。）
        （真实场景  一些命令行程序设计者经常问我的一个问题是：如何在命令shell中回显一个空行？ 你可能认为在某行中键入ECHO命令即可，但实际上并非如此。就像上面的提示中所说的，键入echo将会显示命令回显状态，键入echo并在其后跟随空格也不能做到这一点，命令shell会认为这个空格是无意义的（在这个场景中），因此与只键入echo是一样的结果。要想让ECHO显示一个空行，必须键入echo和一个句点（echo.）。这里，句点是命令的一部分，必须紧随在ECHO命令之后。）
    3.2.4使用@对命令回显进行调整
        @命令可以以行为单位来防止命令回显到输出中，在一定意义上可以理解为特定于某行的echo off语句。使用@命令，可以通过如下方式关闭命令回显：
        @echo The system host name is :
        @hostname
        使用@命令后，以如下形式输出命令提示符与命令的：
            c:\echo The system host name is:
            The system host name is:
            c:\hostname
            mailerl
        会变成：
            The system host name is:
            mailerl
        当然，@的真正价值在于可以使得明亮shell不再显示命令提示符或ECHO OFF命令，确保脚本的输出信息只包含所键入命令的输出。下面给出一个脚本实例，其中使用@来隐藏ECHO IFF命令，时期不再输出信息中显示：
            @echo off
            echo The system host name is:
            hostname
        运行之后上面的脚本的输出为：
            The system host name is :
            mailerl
        （提示  我建议在所有命令行监本前使用@echo off。另外，在命令shell中键入@echo off，也可以关闭命令提示符的回显。）
    3.2.5设置控制台窗口的标题与颜色
        编写命令行脚本时，可以加入一些特性使其更加醒目。前面已经讲述了一些基本的技术，包括使用ECHO OFF命令关闭命令回显、写入输出信息之前清空控制台窗口等。出这些工作外，在实际应用中，你可能还会希望设置命令shell窗口标题栏，或者改变窗口显示的颜色。
        命令shell的标题栏定位在控制台窗口的上方。通常情况下，标题栏显示的是“命令提示符”，或者命令提示符的路径。通过title命令，可以对标题栏进行定制。该命令与ECHO命令类似，会在控制台的标题显示其后跟随的文字。比如，如果想将当前控制台窗口的标题设置为System Information，可以在命令行中输入如下命令：
        title system Information
        通过title命令，不仅可以展示运行中的脚本名，还可以展示脚本运行的进度，如下所示：
            rem add blocks of work commands
            title Gathering Information

            rem add blocks if logging commands
            title Logging system Information
        默认情况下，控制台窗口会以黑色背景展示白色文字。在第1章中曾经讲过，可以使用“命令行属性”对话框的“颜色”选项卡修改它。另外一种方法是使用color命令，带一个由两个数字组成的十六进制代码参数，其中第一个数字代表背景颜色，第二个数字代表文字颜色。如下面的命令所示，该命令将文字颜色设置为蓝色，背景颜色设置为绿色：color 21
        表中列出了color命令可以使用的颜色代码。需要注意的是，文字颜色与背景颜色不能设置为相同，如果这样设置，则该命令不会起作用。此外，任何时候都可以使用color命令（不带参数）恢复默认的颜色设置，如下所示：
            ----------------------------------------------------
            代码|颜色             |代码|颜色
            ---------------------|----------------
            0   |黑色             |8  |灰色
            1   |蓝色             |9  |浅蓝色
            2   |绿色             |A  |谈绿色
            3   |浅绿色           |B  |浅水绿色
            4   |红色             |C  |浅红色
            5   |紫色             |D  |淡紫色
            6   |黄色             |E  |谈黄色
            7   |白色             |F  |亮白色
3.3向脚本传递参数
    与大多数命令行工具类似，你也可以在脚本启动时向其传递参数。通过使用参数，可以设置脚本中特殊的变量，或者传递脚本运行需要的信息。参数应该跟随在脚本名之后，不同的参数应该使用空格分隔开（必要的时候还要将多个参数用引号封装起来）。在下面的实例中，向一个名为check-sys的脚本传递了参数mailerl与full：
        check-sys mailerl full
    传递给脚本的每一个值都可以用形参进行检查与解释。脚本名本身由%0表示，%1代表传递给脚本的第一个参数，%2代表传递给脚本的第二个参数。依此类推，直到%9，代表传递给脚本的第9个参数。比如，如果创建了check-sys脚本，并使用如下命令调用该脚本：
        check-sys mailerl full actual
    则相关的参数值分别是：
    · %0：check-sys
    · %1：mailerl
    · %2：full
    · %3：actual
    在脚本中，可以使用形参名来访问实参：%0代表脚本名，%1代表第一个实参，依此类推。比如，如果想要显示脚本名与传递给脚本的第一个实参，可以输入如下命令。
        echo %0
        echo %1
    如果向脚本传递了多于9个参数，多余的参数并不会丢掉，而是保存在一个特殊的变量%*中（百分号+星号）。%*代表了传递给脚本的所有实参，通过shift命令即可查看多余的实参。如果不带参数运行shift命令，则脚本形参左移一个。这意味着，%0代表的相关值被丢弃，并由%1代表的相关值替代，%1代表的相关值被%2代表的相关值替代，依此类推。必要的时候，也可以指定从何处开始进行形参移位，以便保留前面的参数。比如，如果使用下面的命令，则%4变为%3，%5变为%4，依此类推，但%9、%1、%2不受影响：shift /3
3.4熟悉变量
    在命令行脚本中，我们通常所说的变量更可能指的是环境变量。环境变量有很多种来源，其中一些内置在操作系统之中，或者启动时来自系统硬件，这种变量称为内置的系统变量，对所有Windows进程都是可用的，而不管是否有人交互式地登录系统。系统变量也可以来自Windows注册表。除这种内置的系统变量之外，还有一些登录时设置的变量，这种变量称为内置的用户变量。内置的用户变量是相同的，而不管是哪个用户登录系统。此外，这些内置的用户变量只有在某次实际的登录会话（也即某用户登录了系统）中才是有效的。
    通过在命令提示符中键入set，可以查看当前命令shell实例中所有已知的变量。除标准的系统与用户变量外，也可以在Windows运行中随时创建与设置变量--实际上这就是在命令shell中进行程序设计时所要做的工作。使用set命令与下面的语法，就可以为当前命令shell实例定义变量：
        set veriable_name=veriable_value
    比如
        set working=c:\work\data
        set value=5
        set string="Hello world"
    有些变量（包括系统与用户环境变量）在命令shell中有特殊的含义，包括path、computername、homedrive以及很多其他重要的环境变量。此外，有一个需要学习和关注的环境变量errorlevel，该变量可以追踪最近使用命令的退出代码。如果命令正常执行，则错误级别为0；如果命令执行过程中出错，则错误级别会被设置为一个适当的非0值。下麦你是相关的错误类型值。
    · 1。代表通常的错误。
    · 2。代表执行错误，意味着命令没有正确执行。
    · -2.代表算术错误，比如创建了一个命令shell无法处理的过大的数值。
    可以以多种方式使用errorlevel变量，比如，检查特定的错误条件：
    if "%errorlevel%"==2 echo  "An error occurred!"
    或者，也可以使用如下的语法检查是否出现等于或大于指定的退出代码的错误条件：
    if errorlevel 2 echo "An error ocurred!"
    （注解  在本章3.5.3节与3.7节，将会更多地讲述errorlevel、if语句的相关内容。）
    使用完某变量之后，应该对其进行适当处理，以便释放该变量占用的内存，防止无意间再次引用该变量是出现问题与预期外的结果。要清除一个变量，很简单的方法是将该变量设置为空，如下所示：
        set working=
    之后，变量working将不复存在。
3.5在脚本中使用白能量
    在脚本中，变量主要用于存储多种操作中涉及的各种值。与大多数程序设计语言不通的是，在脚本中声明变量时必须同时为其赋具体的值。这样做是有一定意义的，因为从实用主义的观点看，没有理由定义一个不包括任何值的变量。随后的几节将讨论在脚本中使用变量的一些关键概念，包括：
    · 变量名
    · 变量值
    · 变量替换
    · 变量作用范围。
    3.5.1变量命名
        命令shell可以区分变量名中使用字母的大小写，但在引用变量名时并不区分大小写。也就是说，变量名不是大小写敏感的，但是可以区分大小写。除此之外，对变量名的限制是非常少的，你可以使用任意的字母、数字、字符组合在一起构成变量名。比如，下面的变量名，理论上都是有效的变量名：
            2six
            85
            ！
            ？
        这些变量名虽然有效，但易读性很差。因此，实际应用中一般不会采用这种变量名。在定义变量名时，最重要的一点就是变量名具有较好的描述性，即通过变量名本身就可以大概知道变量的用途，如下所示：
            system-name
            currentStats
            mergetotal
            Net_Address
        对使用或修改脚本的人而言，这种描述性很好的用户名是很有帮助的。当然，这种多字型变量名的命名方式有很多种，理论上都有效，不过大多数程序设计人员在创建这种多字型变量名时，第一个单词会以小写字母开头，而后续的其他单词会以大写字母开头，这是一种标准的命名约定。根据这种约定，上面列出的变量名实际上应该采用如下形式：
            systemName
            currentStats
            mergeTotal
            netAddress
        （注解  要记住的是，命令shell不关心变量名是大写还是小写。也就是说，尽管命令shell有能力区分变量名中字母的大小写，但引用变量名时并不分区大小写。因此，对于上面定义的变量名systemName，可以使用SYSTEMNAME，systemname，甚至sYStemNAMe等多种方式进行引用。）
    3.5.2设置变量值
        前面已经讲过，可以使用如下的语法来定义新变量。其中，variable_name是变量名，variable_value是变量值：
            set variable_name=variable_value
        在变量名与变量值中，空格都是有效的。因此，如果希望变量名与/或变量值中包含空格，可以在等号（=）附近设置空格。
        与很多程序设计语言不同的是，命令shell不对不同的数据类型进行区分，所有变量都已字符串的形式存储，即便将变量值设置为数值时也是如此。因此，如下的变量值是以字符串形式存储的：
            Current status：
            331
            “Error!”
            12.75
            要设置这些值，则需要使用如下命令：
            set varA=Current status:
            set varB=311
            set varC="Error!"
            set varD=12.75
        要注意的是，有些字符是命令行的保留字符，包括@、<、>、&、|、^等字符。在使用这些字符时，不管出现在变量值中的哪个位置，都必须使用换码字符^对其进行换码（第2章中对其进行了讨论）。比如，要设置如下形式的字面意义的字符串值；
            2&3=5
            2^3
            就必须使用如下的变量值：
            2^&3=5
            2^^3
        使用的命令形式则为：
            set example1-2 ^& 3 = 5
            set example2=2^^3
        (注解  试图对上例中的变量值进行回显时，会发生一些奇怪的现象。与想要看到的等式不同，你或者会得到出错信息，或者会得到奇怪的值。回显变量值时之所以会出现这种现象，是因为命令shell对特殊字符进行了重复分析。如果想将变量值设置为包含特殊字符，同时又可以将该值向用户显示，就必须使用3个换码字符^。比如对上面的例子，就需要使用set examp,e1=2^^^&3=5或set example2=2^^^^3。这样做是必要的，因为这些值被重复分析了（一次是在这些值被设置的时候，一次是在这些值被显示的时候）。)
    3.5.3替换变量值
        如果仅仅能使用set命令对这些变量值进行设置，意义是很有限的。幸运的是，你可以通过其他方式访问变量。其中的一种是变量替换，用于对变量名与其真实值进行比较。在下面的命令行中，给出了一个这种替换的实例：
            if "%ERRORLEVEL%"=="2" echo "An error occurred!"
        该命令行的作用是确定环境变量errorlevel的值是否等于2，如果是，则显示一个字符串声明发生了错误。其中，用两个百分号将变量名封装在一起的作用是使得命令shell知道当前正在引用一个变量，如果没有使用百分号，则Windows会对"ERRORLEVEL"与2进行字面意义上的比较。另外还要注意其中使用了引号，其作用是确保对字符串值进行比较。
        另外一种使用替换的方法是用变量的真实值替代变量名。比如，为创建一个可以在不同计算机上运行的脚本，就不能将系统根目录硬编码为c:\windows，而是使用环境变量systemroot，在特定计算机上运行脚本时，该变量会引用该计算机的系统根目录。因此，在脚本中，应该使用如下代码：
            cd %SYSTEMROOT%\System32
        而不是使用如下代码：
            cd c:\windows\system32
            为变量赋值时，也可以使用变量替换，比如：
            systemPath=%SystemRoot%\system32
        变量替换的作用是相当强大的，命令清单中的代码展示了这一点。
            @echo off
            @if not "%OS%"=="windows_NT" goto :EXIT
            @if "%1"=="" (set INFO=echo && set SEXIT=I) else (set INFO=rem && set SEXIT=0)

            %INFO% ************************
            %INFO% Script : SystemInfo. bat
            %INFO% Creation Date: 2/28/2008
            %INFO% Last Modified: 3/15/2008
            %INFO% Author: William R. Stanek
            %INFO% E-mail : Williamstanek@aol.com
            %INFO% *************************
            %INFO% Description: Displays system configuration information
            %INFO%              including system name, IP configuration
            %INFO%              and Windows version.
            %INFO% **************************
            %INFO% Files :stores output in c:\current-sys.txt
            %INFO% **************************

            @if "%SEXIT%"=="I" goto :EXIT

            @title "Configure Scheduling..."
            Cls
            color 07
        命令清单是我在很多脚本中都会使用的标准的脚本头部信息，其中，第一个if语句用于检查当前运行的操作系统，如果是Windows 2000或后续版本，则脚本继续执行，否则会调用一个goto子过程。第二个if语句用于检查传递给脚本的第一个参数值，如果调用脚本时没有使用参数，则%INFO%实例会被echo（用于将脚本文档写入到输出）替换；如果调用脚本时使用了一个或多个参数，则%INFO%实例会被rem替代，用于指明相关联的行为注释信息。
        （注解 如果不能完全理解上面的实例，不必担心。在本章3.7节与3.9节，会详细讲述关于条件执行与子程序方面的内容。）
    3.5.4变量作用范围局部化
        在命令shell中，使用set命令对变量所做修改的作用范围是局部化的。这意味着，这些变量只适用于当前的命令shell实例，或当前命令shell中启动的命令shell（嵌套的命令shell），对其他系统进程则是无效的。进一步地说，退出命令shell（变量是在其中创建的）后，这些变量就不复存在。
        有时候，可能需要对变量作用范围进行进一步的限制，使其作用范围局限于某一部分。要做到这一点，可以在脚本上创建一个局部范围，使得变量的改变只作用于脚本中某个特定的区域。在脚本的后面，可以终止局部范围，并将环境恢复到原始位置。
        要完成局部范围的设定工作，可以在脚本中使用SETLOCAL命令来标记一个局部范围的开始，使用ENDLOCAL命令来标记一个局部范围的结束。使用这些命令时，实际上进行了一些幕后工作。调用SETLOCAL命令会创建当前环境的一个快照，在该局部范围内的任何变量变化都将局部化在该范围之内，调用ENDLOCAL命令时，局部范围内的变量变化与环境都将恢复至原始状态。下面给出了一个使用SETLOCAL命令与ENDLOCAL命令的实例：
            @echo off
            set sysCount=0
            set deviceCount=0

            rem Start localization
            setlocal
            set sysCount=5
            set deviceCount=5
            echo Local count: %sysCount% system edits ^& %deviceCount% dev ice checks
            endlocal
            echo Count: %sysCount% system edits ^& %deviceCount% dev ice checks
        该脚本的输出为：
            Local count: 5 system edits & device checks
            Count: 0 system edits & 0 device checks
        可以看出，局部分为与嵌套命令shell是类似的，也可以嵌套多层局部范围。但嵌套层局部范围中的变化不会影响到上一层，尽管每一层都会从上一层中继承环境设置。
3.6使用数学表达式
    脚本中不时地需要进行一些数学运算，并将结果赋给某变量。与大多数程序设计语言类似，命令shell中也可以使用大量运算符来构建数学表达式，如下所示。
    · 算术运算符。用于执行标准的数学操作（比如加、减乘、除）。
    · 赋值运算符。将赋值操作（由等号表示）与算术操作结合起来。
    · 比较运算符。用于对值进行比较，通常与if语句一起使用。
    · Bitwise运算符。用于对二进制值序列进行操作。
    算术操作是使用SET命令（带参数/A）进行的，比如：
        set /a theTotal=18+2
        set /a theTotal=18*2
        set /a theTotal=18/2
    所有的数学表达式都针对32位有符号整数进行运算，取值范围是-2^32到2^32+1。如果超过了这一取值范围，就会报告算术错误，而得不到正确的结果。
    最常用的运算符是用于算术运算、赋值操作、比较操作的运算符，算术运算符与赋值运算符随后就会进行讨论，比较运算符则会在本章3.7.5节讲述。另外，还应该特别注意关于运算符优先级以及在脚本中模拟指数操作的讨论。
    3.6.1使用算术运算符与赋值运算符
        算术运算符用于对数值进行一些基本的数学运算，这些数值或者可以表现为数字的形式，比如数字5.也可以表现为变量的形式（其中包含了要使用过的变量值），比如%TOTAL%。
        表总结了可用的算术操作符与赋值运算符。大部分算术运算符的含义都是非常明显的，比如，运算符*用于乘法操作，运算符/用于除法操作，运算符+用于加法操作，运算符-用于减法操作。等号（=）表示赋值运算符，用于将变量值赋给变量，%（模数） 则用于获取除法操作的余数部分。比如，用60除以8，则结果为7余4，使用%（模数）运算符时，4就是得到的结果。
        下面给出了几个使用算术运算符的实例：
            set /a theCount=5+3
            set /a theCount=%nServers% + %nWstations%
            set /a theCount=%nServers% - 1
        （提示  前面曾经讲过，变量中存储的变量值都是字符串，这一点在使用算术运算符的语境下仍然是对的。不过，命令shell可以判断出什么情况下字符串中包含的都是数字。因此，在算术表达式中使用变量是可以的。要记住的关键点是使用正确的语法进行替换操作：%variableName%。）
            ------------------------
            算术操作符|赋值操作符
            ------------------------
            +（加）   |+（加之后赋值）
            -（减）   |-（减之后赋值）
            *（乘）   |*（乘之后赋值）
            /（除）   |/（除之后赋值）
            %（模）   |%（模之后赋值）
            -------------------------
        使用赋值运算符，可以进行递增、递减、按比例增加、缩减等操作。这些运算符实际上也结合了算术运算符的功能。比如，+=运算符用于对某个值进行加操作再重新赋值，实际上就结合了+运算符与=运算符的功能。因此，如下两个表达式是等价的，返回的是童颜过的结果：
            set /a total=total+1
            set /a total+=1
    3.6.2理解运算符的优先级
        使用算术运算符工作时，理解运算符优先级是必要的。在表达式中涉及到多个运算符时，运算符优先级会决定其执行顺序，比如：
            set /a total=8+3*4
        如果简单地从左至右进行运算，则上面表达式的结果为44（8+3=11， 11*4=44）。然而，在数学运算中，上述表达式的结果实际上应该是20（3*4=12， 8+12=20）。这是因为，表达式中的运算符具有如下的优先级：
        （1）模数运算：
        （2）乘法操作与除法运转
        （3）加法操作与减法操作
        （注解  表达式中包含多个同优先级的云算法时，则采用自左至右的顺序进行运算。因此，set /a total=10-4+2的值为8（10-4=6， 6+2=8）。）
        然而，在数学运算中，可以使用括号将算术表达式的某些部分包含在一次，从而改变运算的优先级。因此，通过如下表达式：
            set /a totla=(8+2)*4
        可以使得命令shell将其解释为8+3=11、11*4=44，所以结果为44。
    3.6.3模拟指数操作
        尽管可以在命令行中进行很多，数学运算，但无法使用指数操作运算符。不过，可以通过人工的方式进行指数运算。比如，要计算2^3的值，最简单的方法是输入如下命令：
            set /a total=2*2*2
        上述表达式的结果为8.同样地，要计算10^5的值，可以输入如下命令：
            set /a total=10*10*10*10*10
        上述表达式的结果是1000000.
3.7命令行选择语句
    前面讲解了如何使用变量与规范的表达式，下面讨论命令行脚本中一些更高级的功能：在命令行中，是使用选择语句。如果想控制脚本的执行流程，但相应的判别条件只能在运行时才可以确定，则可以采用如下方法。
    · 使用if语句。在条件为针（比如，操作系统为Windows 2000及后续版本）时执行某句，否则绕过该语句。
    · 使用if not语句。在条件为假（比如，某系统中不包含c:\windows目录）时执行某语句，否则绕过该语句。
    · 使用使用if…else语句。在条件匹配（真或假）时执行某语句，否则执行另外的语句。
    尽管本章前面的一些例子中已经使用了条件执行语句，但我们没有讨论这些语句的语法，以及相关联的比较操作符。如果你不具备程序设计的背景知识和经验，你可能会为这些语句的强大功能与灵活性而深感惊讶。
    3.7.1使用if语句
        if语句用于条件分支，可以将脚本的执行引导向两条不同过的执行路径，其基本语法为：
            if codition (statement1) [else (statement2)]
        这里，每条语句可以是单一的命令，也可以由多条命令组成。这些命令可以组成命令链，可以使用管道连接，也可以使用圆括号进行分组。条件可以是任意的表达式，该表达式可以返回布尔类型的True（真）或False（假）。else子句是可选的，也就是说，你也可以使用如下的语法：
            fi condition (statement)
        （提示  理论上讲，圆括号并不是必需的，但是使用圆括号可以使得语句的结构更加清晰，尤其在条件中包含了echo语句或带有参数的命令时更是如此。在这些情况下如果不使用圆括号，则当前行中在该语句之后的所有内容将被解释为语句的一部分，所以经常会导致错误。）
        if语句的工作方式：如果条件为真，则执行语句1，否则执行语句2（前提是if语句中也使用了else子句）。在任何情况下，if子句与else子句都不会同时执行。参考下面的实例：
            if "%1"=="1" (echo is one) else (echo is not one)
        这里，如果传递给脚本的第一个参数是1，则is one被写入到输出。否则，is not one被写入到输出。
        在每一个条件后面，命令shell只会执行一个语句。典型情况下，该语句可以是单一的命令。如果想在判别条件后执行多条命令，可以使用命令管道、命令链、命令分组等技术，如下所示：
            if "%1"=="1" (hostname & ver & ipconfig /all) else (netstat -a)
        这里，如果第一个参数为1，则第一组圆括号中的所有3条命令都将执行。
    3.7.2使用if not 语句
        如果希望在条件为假（false）的情况下才执行命令，则可以使用if not语句，其基本语法为：
            if not condition (statement1) [else (statement2)]
        这里，命令shell对条件进行判断。如果条件为假，则执行语句1.否则不执行语句1，且命令shell继续执行到语句2（如果存在）。else子句是可选的，也就是说，除上面的语法外，也可以使用如下的语法：
            if not condition (statement1)
        参考下面的实例：
            if not errorlevel 0 (echo An error has occurred!) & (goto :EXIT)
        这里，命令shell对非0的错误条件进行检查。如果没有错误发生（也即错误级别为0），则命令shell跳转到下一条语句。否则，命令shell将An error has occurred！写入到输出，并退出脚本。（本章后买将讲述关于goto语句与子过程的详细内容）
    3.7.3使用if defined与if not defined语句
        最后两种可以使用的if语句是if defined与if not defined，这两种语句可用于检查某变量是否存在，两种语句的语法格式分别为
            if defined variable statement 和 if not defined variable statement
        在shell脚本中，这两种语句都是有益的。第一种情况，如果指定的变量存在，则执行某条命令。第二种情况，如果某变量不存在，则执行某条命令。参考如下的实例：
            if defined numServers (echo Servers: %numServers%)
        这里，如果变量numServers已经定义，则脚本向输出写入信息。否则，脚本跳转下一条语句。
    3.7.4使用嵌套的if语句
        嵌套的if语句是指在if语句中又包含了其他的if语句，这种语句在程序设计中是很常见的，命令shell程序设计中也是如此。使用嵌套的if语句时，需要注意如下几点。
        · 使用花括号定义代码块，使用@符号标记嵌套循环语句的开始。
        · else语句总是与同一代码块内最邻近的if语句匹配，前提是该if语句没有与任何其他的else语句关联起来。
        下面给出一个实例：
            if "%1"=="1"(
            @if "%2"=="2"(hostname & ver) else (ver)
            ) else (hostname & ver & netstat -a)
        这里，第一个else语句是与if "%2"=="2"匹配的，后一个else语句则与语句if "%1"=="1"匹配。
    3.7.5在if语句中进行比较
        如前面一些例子中所示，用于控制if语句的表达式中经常涉及到比较运算符。最基本的字符串比较类型是使用等号（=）对两个字符串进行比较，如下：
            if stringA==stringB statement
        这里，对字符串进行了字面意义的比较。如果两个字符串完全等同，则执行后面的语句。这种语法格式对字面意义的字符串是有用的，但对脚本不是很适用。形参与实参中更可以包含空格，或者某变量可以不进行赋值。在这种情况下，如果进行字面意义的比较，就会得到错误信息。为避免这种错误，可以使用双引号包括起来进行字符串比较，并防止大多数错误，比如：
            if "%varA%"=="%varB%" statement
            或者：
            if "%varA%"=="string" statement
        字符串比较总是区分大小写的，除非制订了/i参数。/i参数会使得命令shell在进行字符串比较时忽略字母大小写，如下所示：
            if /I "%1"=="a" (echo A) else (echo is not A)
        要进行更高级的相同性测试，可以使用表中列出的比较运算符，这些运算符可以替代标准的等号运算符，比如：
            if "%varA%" equ "%varB%" (echo The values match!)

            --------------------------------------------------------------
            运算符|描述
            ------|-------------------------------------------------------
            equ   |检查两个值是否相等，如果相等，则结果为真
            neq   |检查两个值是否不想等，如果不想等，则结果为真
            lss   |检查两个值之间的小于关系，如果值1小于值2，则结果为真
            leq   |检查两个值之间的小于等于关系，如果值1小于等于值2，则结果为真
            gtr   |检查两个值之间的大于关系，如果值1大于值2，则结果为真
            geq   |检查两个值之间的大于等于关系，如果值1大于等于值2，则结果为真
            ---------------------------------------------------------------
3.8命令行迭代语句
    如果需要重复地执行一条命令或一系列命令，可以使用for语句。for语句具有非常强大的功能，如果你认为自己了解for语句而想跳过本节的内容，建议你放弃这种不明智的想法。本节讲述的for语句是专门为命令shell环境设计的，与你以前在其他程序设计语言环境中使用的for语句有很大的不同。命令行中的for语句主要用于在成组的文件与目录中进行迭代处理，并以行为基础分许文本文件、字符串以及命令的输出信息。
    3.8.1迭代的基础
        命令shell有几种不同形式的for语句，最基本的for语句形式为：
            for iterator do (statement)
        这里，iterator用于控制for循环的执行。对iterator中每一步骤或元素，都会执行特定的语句。他可以是单一的一条命令，也可以是使用命令管道、命令链、命令分组等技术组合起来的多条命令。
        iterator通常包含一个初始化变量和一组需要反复执行的元素，比如需要遍历的一组文件或某范围内的一组值。初始化变量实质上是要使用的值的占位符，使用初始化变量时，应该注意如下几点。
        · iterator变量只存在于for循环的上下文中。
        · iterator变量名必须在a~z或者A~Z的范围内，比如%%A、%%B、%%C。
        · iterator变量名是大小写敏感的，也就是说，%%A与%%a是不同的。
        如表中所示，用于for循环语句的不同结构具有特定的用途与形式。for语句初始化时，iterator变量，比如%%B，会被其真实值替代。这些值来自于for循环语句中指定的元素值，可以包含一组文件、一组目录。某范围内的一组值等。
            ------------------------------------------------------------------------------------
            迭代用途                      |语法格式
            -----------------------------|------------------------------------------------------
            文件集合                      |for %%variable in (fileSet) do statement
            目录集合                      |for /D %%variable in (directorySet) do statement
            子目录中的文件                |for /R [path] %%variable in (fileSet) do statement
            遍历一系列的值                |for /L %%variable in (stepRange) do statement
            分析文本文件、字符串以及命令输出|for /F ["options"] %%variable in (source) do statement
            -------------------------------------------------------------------------------------
        （真实场景  上表中提供的是for脚本中的不同迭代形式，也可以在命令行中交互式地使用for语句，这种情况下，应该使用%variable，而不是%%variable。除此之外，脚本中的for语句与命令行中使用过的for语句在处理上是一致的。）
    3.8.2遍历一系列值
        使用for语句的传统方式是遍历某范围内的一系列值，并使用这些值执行相应任务。在命令shell中也可以做到这一点，其基本语法为：
            for /l %%variable in (start,step,end) do (statement)
        这种类型的for语句以如下方式运行。首先，命令shell对内部变量start、step、end进行初始化，将其赋值为应用中实际指定的值。之后，命令shell对start值与end值进行比较，如果start值可以按step中指定的值进行递增或递减操作，则条件为真（或按照另一种约定，条件为假），根据判别条件的真假来判断是否需要执行语句。在条件为真的情况下，命令shell使用start值执行语句，并根据指定的step值对初始值进行递增或递减操作，之后重复这一过程直至遍历所有的值，或者条件发生变化。在条件为假的情况下，命令shell退出for循环语句，并跳到脚本中的下一语句执行。
        参考如下的实例，该实例对0到10进行技术，step值为2：
            for /l %%B in (0,2,10) do echo %%B
            该语句的输出为：
            0
            2
            4
            6
            8
            10
        你也可以使用负的step值，使得for语句以值递减的方式执行。比如，在下面的实例中，对10到0进行计数，step值为-2：
            for /l %%B in (10, -2, 0) do echo %%B
            该语句的输出为：
            10
            8
            6
            4
            2
            0
    3.8.3在成组的文件中迭代执行
        在命令shell中，for语句更强大的功能是对文件与目录进行处理。处理成组的文件时，基本的for语句语法为：
            for %%variable in (fileSet) do (statement)
        这里，fileSet用于指定需要处理的文件集，文件集可以为如下的形式。
        · 通过文件名指定的单独的文件，比如MyFile.txt。
        · 通过文件名通配符指定的一组文件，比如*.txt。
        · 通过多个文件名（使用空格分割）指定的多个或多组文件，比如*.txt*.rtf*.doc。
        了解这些基本规则后，使用for语句进行文件处理是很容易的。比如，如果想列出某应用程序目录中所有文本文件，可以izai脚本中使用如下的命令：
            for %%B in (C:\working\*.txt) do (echo  %%B)
        这里，B为初始化变量，C:\working\*.txt指定了对C:\working目录下所有文本文件进行处理。要循环执行的语句为echo %%B，通过该语句，在for循环的每次迭代中，命令shell都会展示%%B的当前值。上面语句的执行结果是，C:\working目录中的文本文件列表被写入到输出中。
        通过对上面的命令进行扩展，就可以列出所有.txt文件、.rtf文件与.doc文件，如下所示：
            for %%B in (%AppDir%\*.txt %AppDir%\*.rtf %AppDir%\*.doc) do (echo %%B)
        进一步地，还可以使用命令管道、命令链、命令分组等技术，如下所示：
            for %%B in (%AppDir%\*.txt %AppDir%\*.rtf %AppDir%\*.doc) do (echo %%B & move c:\data)
        在该命令中，列出了由AppDir变量指定的位置中所有.txt文件、.rtf文件与.doc文件，并将这些文件移动到c:\Data目录。
    3.8.4在目录中迭代执行
        如果箱操作目录，则可以是用如下的for语句格式：
        
