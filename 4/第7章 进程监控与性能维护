第7章  进程监控与性能维护

管理员的一项重要工作就是监控网络系统，并确保一切运行正常或处于允许的范围内。第6章曾经讲过，密切关注事件日志有助于检测与追踪应用程序、系统安全以及基础服务方面存在的问题。通常，检测到或怀疑某处存在问题时，应该对其进行深入挖掘，以便找到导致问题的根源并加以纠正。但愿查明问题的根源，可以防止该问题再次发生。

7.1管理应用程序、进程与性能
    操作系统或用户启动服务、运行应用程序或执行命令时，Windows会启动一个或多个进程来处理相关的程序。有几款命令行工具可用于监控与管理程序，包括下面3个。
    · Task List（Tasklist）。列出所有运行中进程的名称与进程ID，包括用户会话与内存使用等信息。
    · Task Kill（Taskkill）。根据名称或进程ID终止运行中的进程。通过使用过滤器，也可以根据进程状态、会话号、CPU时间、内存使用情况、用户名以及其他信息来终止进程。
    · Powershell get-process。显示性能数据的统计资料，包括CPU与内存使用情况、所有运行中进程列表等。用于获取资源使用情况与所有运行中进程的详细资料快照，只有在安装了Windows PowerShell之后才是可用的。
    在接下来的内容中，将会详细讲解如何使用这些命令行工具。不过在具体讲解之前，先介绍一下进程的通常运行方式以及操作中常见的问题。
    7.1.1理解系统与用户进程
        通常，有操作系统启动的进程称为系统进程，由用户启动的进程称为用户进程。大多数用户进程是以交互模式运行的，也就是说，用户启动进程时要与键盘或鼠标进行交互。如果应用软件或程序处于活跃状态并被选定，则相应的交互式进程就控制了键盘与鼠标，直至切换控制权（通过终止相应程序或选定其他程序）。当某进程具有控制权时，就称其为在“前台”运行。
        进程可以独立于用户登录会话在后台运行，后台运行的进程不具备对键盘、鼠标或其他输入设备的控制权，通常由操作系统运行。通过使用任务计划程序，用户也可以将进程设定为在后台运行，并且这些进程的运行不受用户是否登录的影响。比如，如果任务计划程序在某用户登录时启动一个计划任务，该用户退出登录时，该进程会继续运行。
        Windows对系统中运行进程的追踪是通过镜像名、进程ID、优先级以及其他一些记录资源使用情况的参数来实现的。镜像名是启动该进程的可执行程序的名称，比如Msdtc.exe或Svchost.exe。进程ID是该进程的数字标识符，比如2588.进程ID还是一个优先级指示器，代表了该进程与其他运行中进程相比而言获取系统资源的优先程度。在进行优先级处理时，具有高优先级的进程可以比低优先级的进程更快地获取处理器时间、访问内存或操作文件系统。而低优先级的进程必须等待高优先级进程完成当前的处理任务之后，才可以访问CPU、内存或文件系统。
        理想情况下，进程应该正确地按计划运行，而不出现任何问题。然而，实际的情况则是在你最不希望出问题的时候通常会出现问题。就进程而言，常见的问题包括下面3个。
        · 进程失去响应。比如，应用程序停止处理外部的请求。发生这种情况时，用户会报告无法访问特定的应用程序，提交的请求无法得到处理，或者被踢出该应用程序。
        · 进程不释放CPU资源。比如，某个失控进程几乎耗尽CPU资源。发生这种情况时，系统会变慢或失去响应，这是因为失控进程霸占了处理器时间，导致其他进程无法完成自己的任务。
        · 进程占用的内存空间超过了正常的需求。比如，应用程序发生了内存泄露。发生这种情况时，进程无法正常释放其所使用的内存资源，由此导致的结果是系统中可用内存逐渐下降，使得系统对外部响应变慢，或者失去响应。内存泄露还有可能导致系统中其他程序无法正常运行。
        大多数情况下，发现系统进程存在上述问题或其他问题后，你可能需要终止该进程之后重启，并根据需要检查时间日志以便发现导致问题的根源。对内存泄露的情况，你可能需要向开发人员报告，必变发现是否有可用的更新程序。
        此外，对存在内存泄露问题的应用程序，定期进程重启也是有用的。重启之后，操作系统会进行泄露内存的恢复。
    7.1.2检查运行中进程
        如果需要检查本地或远程系统上运行的进程，可以使用Tasklist这一命令行工具。通过该工具，可以完成如下一些任务。
        · 获取系统中运行进程的进程ID、状态以及其他一些重要信息。
        · 查看运行中进程与系统中已配置服务的关系。
        · 查看运行中进程使用的DLL。
        · 使用过滤器包含或排除Tasklist查询获得的进程列表。
        下面几节逐一讨论了这些任务。
        1.获取进程的详细信息
        在本地系统上，通过在命令提示符中键入tasklist命令，就可以查看运行中任务列表。与很多其他的命令行工具类似。默认情况下，Tasklist以当前登录用户的许可权限运行。你也可以指定远程主机（要查询其上的任务）以及Run As许可权限，这是通过使用包含如下一些参数的扩展的语法格式实现的：
            /s Comouter /u [Domain\]User[/p Password]
        其中，Computer为远程计算机名或IP地址，Domain为可选的域名，用户账号就存在于该域内，User为用户账号名（要使用的就是用户账号的许可权限），Password为该用户账号的口令（可选）。如果没有指定域，则系统会假定当前域作为默认的域名。如果没有指定口令，则会弹出提示信息要求输入口令。
        要了解如何添加计算机与用户信息，参考如下一些实例。
        查询Mailer1上运行的任务
            tasklist /s mailer1
        查询192.168.1.5上使用账号adatum/wrstanek运行的任务
            tasklist /s 192.168.1.5 /u adatum\wrstanek
        上述命令的基本输出信息是以表格形式呈现的，通过分别使用/Fo List或/Fo Csv参数，也可以使得输出信息分别呈现为列表形式与逗号分隔的多行形式。你也可以使用重定向操作符（>或>>）将输出信息重定向到文件中，比如，tasklist /s mailer1 >> current-tasks.log
        无论是本地系统还是远程系统，输出信息都应该类似于如下的格式：
            ----------------------------------------------------------------------
            Image Name                   PID    Session Name   Session#  MemUsage
            =======================     ===== ============== =========  ==========
            System Idle Process             0 Services               0          28K
            System                          4 Services               0       28952K
            smss.exe                      488 Services               0         776K
            csrss.exe                     560 Services               0        5272K
            wininit.exe                   608 Services               0        4056K
            csrss.exe                     620 Console                1       13004K
            services.exe                  652 Services               0        7456K
            lsass.exe                     664 Services               0        1852K
            Ism.exe                       680 Services               0        6400K
            svchost.exe                   835 Services               0        7228K
            winlogon.exe                  868 Console                1        5544K
            svchost.exe                   932 Services               0        9440K
            svchost.exe                   984 Services               0       23304K
            svchost.exe                  1048 Services               0       12208K
            svchost.exe                  1100 Services               0       71696K
            svchost.exe                  1132 Services               0       36920K
            dwm.exe                      2832 Console                1       65456K
            explorer.exe                 2892 Console                1       26624K
        输出信息中包含如下一些字段。
        · 镜像名。进程或运行该进程的可执行程序的镜像名。
        · PID。进程的ID号。
        · 会话名。运行该进程的会话名，如果取值为console则表明该进程是本地启动的。
        · 会话#。运行该进程的会话标识符。
        · 内存使用。在Tasklist运行时刻该进程的内存总量。
        如果需要获取更多的详细信息，可以指定详细模式。这是通过包含/V参数实现的，使用该参数后，输出信息中会增加如下一些项目。
        · Status。进程的当前状态，可以为运行、无响应或未知。状态为未知的进程仍然可以正常运行与响应，但处于无响应状态的进程通常必须终止或重启。
        · 用户名。运行该进程的用户账号，并以域\用户格式列出。对由Windows启动的进程，用户账号通常为系统账号，比如系统、本地服务或网络服务等，域名则为NT AUTHORITY。
        · CPU时间。该进程自启动到目前为止所使用的CPU时钟周期总量。
        · 窗口标题。如果可用，则Windows显示进程名，否则为暂缺。比如，进程HelpPana.exe的进程名显示为“Windows帮助和支持中心”。
        使用Tasklist对运行中进程进行检查时，可能会发现两个独特的System与System Idle进程。System进程展示了本地系统进程的资源使用情况，System Idle进程则用于表述当前未使用的CPU资源。因而，如果System Idle进程的CPU一列取值为99，则说明当前有99%的系统资源处于闲置状态。如果觉得系统处于过载状态，则应该监控System Idle进程，查看CPU使用情况与总CPU时间。如果系统持续性地处于低空闲时间（即高CPU占用率），则可以考虑对处理器进行升级，甚至添加处理器。
        检查进程时，要记住的一点是：单一的应用程序可能会启动多个进程。通常，这些进程依赖于一个主进程，并以该进程为根形成一颗进程数。终止进程时，通常需要定位并终止该应用程序的主进程，而不是那些依赖性的附加进程，这将确保应用程序的彻底终止。
        2.查看运行中的进程与服务的关系
        运行Tasklist命令时，通过使用/svc参数，可以检查运行中进程与系统中配置的服务之间的关系。输出信息中，包括进程镜像名、进程ID，以及使用该进程的所有服务的列表，类似于如下的格式：
            Image Name                         PID    Services
            ===========================      ========  ==================================================
            System Idle Process                     0  N/A
            System                                  4  N/A
            smss.exe                              488  N/A
            csrss.exe                             560  N/A
            wininit.exe                           608  N/A
            csrss.exe                             620  N/A
            services.exe                          652  N/A
            Isass.exe                             664  KeyIso, ProtectedStorage, SamSs
            Ism.exe                               680  N/A
            svchost.exe                           836  DcomLaunch, PlugPlay
            winlogon.exe                          868  N/A
            svchost.exe                           932  RpcSs
            svchost.exe                           984  WinDefend
            svchost.exe                          1048  Audiosrv, Dhcp, Eventlog, Imhosts, wscsvc
            svchost.exe                          1100  AudioEndpointBuilder,CscService, EMDMgmt,
                                                        Netman, PcaSvc, SysMain,
                                                        TabletInputService, TrkWks, UmRdpService,
                                                        UxSms, WdiSystemHost, Wlansvc, WPDBusEnum,
                                                        wudfsvc
            svchost.exe                          1132  AeLookupSvc, BITS, Brower, CertPropSvc,
                                                        EapHost, gpsvc, IKEEXT, iphlpsvc,
                                                        LanmanServer, MMCSS, ProfSvc, RasMan,
                                                        Schedule, seclogon, SENS, SessionEnv,
                                                        ShellHWDetection, Themes, Winmgmt, wuauserv
            svchost.exe                          1384  EventSystem, fdPHost,FdResPub,
                                                        LanmanWorkstation, netprofm, nsi, SSDPSRV,
                                                        upnphost, W32Time, WebClient
            svchost.exe                          1520  CryptSvc, Dnscache, KtmRm, NlaSvc, TapiSrv,
                                                        TermService
            spoolsv.exe                          1776  Spooler
            svchost.exe                          1800  BFE, DPS, MpsSvc
            dwm.exe                              2832  N/A
            explorer.exe                         2892  N/A
            ----------------------------------------------------------------------------------------------------
        默认情况下，上述命令的基本输出信息是以表格形式呈现的，并且不能使用list或CSV格式。除了格式之外，要注意的重要一点是服务是以缩略名形式列出的，这是Sc（一款用于对服务进行管理的命令行工具）的命名风格。
        你可以使用进程与服务之间的关联关系来对系统进行管理。比如，如果感觉W3svc服务存在问题，对该服务进行故障排除时，一个有用的步骤就是监控该服务对应的进程。监控的主要要素包括：
        · 进程状态
        · 内存使用
        · CPU时间。
        通过对这些信息金层统计追踪，就有可能发现一些线索表明该进程已经通知响应，或者是一个霸占CPU资源的失控进程，或者存在内存泄露问题。
        3.查看进程使用过的DLL
        运行Tasklist命令时，通过使用/M参数，可以检查运行中进程与系统中配置的DLL之间的关系。输出信息中，包括进程镜像名、进程ID以及使用该进程的所有DLL的列表，如下面的实例所示：
            Image Name                          PID  Modules
            ===========================       =====  =========================================
            System Idle Process                   0  N/A
            System                                4  N/A
            smss.exe                            488  N/A
            csrss.exe                           560  N/A
            wininit.exe                         608  N/A
            csrss.exe                           620  N/A
            services.exe                        652  N/A
            lsass.exe                           664  N/A
            lsm.exe                             680  N/A
            svchost.exe                         836  N/A
            winlogon.exe                        868  N/A
            svchost.exe                         932  N/A
            svchost.exe                         984  N/A
            svchost.exe                        1048  N/A
            svchost.exe                        1100  N/A
            svchost.exe                        1132  N/A
            dwm.exe                            2832  ntdll.dll, kernel32.dll, ADVAPI32.dll,
                                                      RPCRT4.dll, GDI32.dll, USER32.dll,
                                                      msvcrt.dll, ole32.dll, OLEAUT32.dll,
                                                      UxTheme.dll, IMM32.dll, MSCTF.dll,
                                                      dwmredir.dll, SLWGA.dll, urlmon.dll,
                                                      SHLWAPI.dll, iertutil.dll, WTSAPI32.dll,
                                                      slc.dll, LPK.DLL, USP10.dll, comctl32.dll,
                                                      NTMARTA.DLL,WLDAP32.dll, WS2_32.dll,
                                                      NSI.dll, PSAPI.DLL, SAMIB.dll,
                                                      milcore.dll, dwmapi.dll, uDWM.dll,
                                                      WindowsCodecs.dll, ctagent.dll, d3d9.dll,
                                                      VERSION.dll, d3d8thk.dll, nvd3dum.dll,
                                                      IconCodeService.dll
            explorer.exe                       2892  ntdll.dll kernel32.dll, ADVAPI32.dll,
                                                      RPCRT4.dll, GDI32.dll, USER32.dll,
                                                      msvrt.dll, SHLWAPI.dll, SHELL32.dll,
                                                      ole32.dll, OLEAUT32.dll, SHDOCVW.dll,
                                                      UxTheme.dll, POWRPROF.dll, dwmapi.dll,
                                                      gdiplus.dll, slc.dll, PROPSYS.dll,
                                                      BROWSEUI.dll, IMM32.dll, MSCTF.dll,
                                                      DUser.dll,LPK.dll, USP10.dll,
                                                      comctl32.dll, WindowsCodecs.dll,
                                                      apphelp.dll, CLBCatQ.dll, cscui.dll,
                                                      CSCDLL.dll, CSCAPI.dll,
                                                      IconCodecService.dll, Secur32.dll,
                                                      rsaenh.dll, msiltcfg.dll, VERSION.dll,
                                                      msi.dll, NTMARTA.dll, WLDAP32.dll,
                                                      WS2_32.dll, NSI.dll, PSAPI.DLL, SAMLIB.dll,
                                                      SFC.dll, sfc_os.dll, SETUPAPI.dll,
                                                      timedate.cpl, ATL.DLL, NETAPI32.dll,
                                                      OLEACC.dll, actxprxy.dll ,USERENV.dll
        获知进程加载了哪些DLL模块有助于确定导致进程不正常（失去响应、不释放CPU，或者占用了超过正常需求的内存）的原因。有些情况下，你可能需要检查DLL版本，以便确定其是否为系统应该使用的DLL版本。为此，你应该查询微软知识库或制造商文档，以便确定DLL版本及其他相关信息。
        如果需要确定有哪些进程使用了某个指定的DLL，也可以在命令中指定DLL名。比如，如果怀疑打印机缓冲池驱动程序Winpool.drv是导致进程挂起的根源，就可以搜索使用Winspool.drv（而非Winspool32.drv）的进程，并检查这些进程的状态及资源使用情况。
        用于指定DLL的语法格式如下：
            tasklist /m DllName
        其中，DLLName为要搜索的DLL名。Tasklist在匹配DLL文件名时不区分大小写，你可以以任意大小写或混合形式输入要搜索的DLL文件名：
            tasklist /m winspool.drv
        通过上面的命令来搜索使用Winspool.drv的进程，其输出信息应该包括所有使用该DLL文件的进程名及各自的进程ID：
            Image Name                 PID  Modules
            ========================  ===== ==============================
            exporer.exe                2892 WINSPOOL.DRV
            rundll32.dll               3308 WINSPOOL.DRV
            acrotray.exe               3340 WINSPOOL.DRV
            IAAnotif.exe               3464 WINSPOOL.DRV
            IntelHCTAgent.exe          3584 WINSPOOL.DRV
            DrgToDsc.exe               3636 WINSPOOL.DRV
            WINWORD.EXE                4836 WINSPOOL.DRV
        4.对Tasklist的输出进行过滤
        通过Tasklist工具的/Fi参数，可以使用任何可用的信息字段对Tasklist的输出进行过滤，即便由于指定参数导致信息字段并没有正常包含在输出信息中。通过这种过滤机制，你可以只查看那些状态为失去响应的进程，或者只查看Svchost.exe进程相关的信息，或者查看占用了大量CPU时间的进程。
        通过使用过滤器操作符，可以过滤特定的Tasklist信息字段，如下的一些过滤器操作符是可用的。
        · Eq。等于，如果进程的某个字段包含了指定的值，则该进程应该包含在输出信息中。
        · Ne。不等于，如果进程的某个字段包含了指定的值，则该进程应该排除在输出信息之外。
        · Gt。大于，如果进程的某个字段包含了大于指定值的数值，则该进程应该包含在输出信息中。
        · Lt。小于，如果进程的某个字段包含了小于指定值的数值，则该进程应该包含在输出信息中。
        · Ge。大于等于，如果进程的某个字段包含了大于或等于指定值的数值，则该进程应该包含在输出信息中。
        · Le。小于等于，如果进程的某个字段包含了小于或等于指定值的数值，则该进程应该包含在输出信息中。
        如表所示，过滤器操作符可以使用的值依赖于该操作符针对Tasklist信息字段。要记住的是，所有字段都是可用过的，即便某些字段不能根据指定的参数正常显示。比如，你可以对status字段进行匹配，而不使用/V (verbose)标记。
            ----------------------------------------------------------------------------------------
            过滤器字段名|有效操作符                    |有效值
            -----------|-----------------------------|-----------------------------------------------
            CPUTime    |eq、ne、gt、lt、ge、le、eq、ne|以hh:mm:ss格式呈现的任意有效值
            Services   |eq、ne                       |任意有效的字符串
            ImageName  |eq、ne                       |任意有效的字符串
            MemUsage   |eq、ne、gt、It、ge、le        |以KB为计数单位的任意有效值
            Modules    |eq、ne                       |DLL名
            PID        |eq、ne、gt、lt、ge、le        |任意有效的正整数
            Session    |eq、ne、gt、lt、ge、le        |任意有效的会话编号
            SessionName|eq、ne                       |任意有效的字符串
            Status     |eq、ne                       |运行、无响应、未知
            Username   |eq、ne                       |任意有效的用户名，只包括用户名，或者以域\用户的格式
            WindowTitle|eq、ne                       |任意有效的字符串
            ------------------------------------------------------------------------------------------
        要注意的是，必须使用双引号对过滤器字符串进行封装。参考如下实例，了解如何使用过滤器。
            寻找失去响应的进程：
                tasklist /fi "status eq not responding"
        对远程系统进行操作时，不能根据进程状态或窗口标题对进程进行过滤。有时候需要这样做，比如通过FIND命令进行管道输出：tasklist /v /s Mailer1 /u adatum\wrstanek | find /i "not responding"。要注意在这一场景中，待过滤字段必须存在于输出信息中，这也是使用/v 参数的原因。进一步地，还可以使用/I参数使得FIND命令忽略字母大小写。
            在Mailer1上搜索占用CPU时间超过30分钟的进程：
                tasklist /s Mailer1 /fi "cputime gt 00:30:00"
            在Mailer1上搜索占用内存超过20000KB的进程：
                tasklist /s Mailer1 /u adatum\wrstanek /fi "memusage gt 20000"
            使用多个/Fi参数，使得输出信息必须同时匹配多个过滤器：
                tasklist /s Mailer1 /fi "cputime gt 00:30:00" /fi "memusage gt 20000"
    7.1.3监控系统资源使用情况与进程
        操作进程时，你通常可能需要获取系统资源使用情况的快照，这会准确展示内存的使用情况。获取快照的方法是使用Typeperf命令，来显示内存对象的关键计数器的当前值。如第6章中所讨论的，内存对象是大量性能对象中国的一种，通过在命令行中键入typeperf -q Memory命令，就可以列出其相关的性能计数器。
        表总结了内存对象中的关键计数器，内存对象的大多数计数器显示的是上一次观测值或当前的百分数，而不是平均值。
            ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            内存对象计数器                  |计数器描述
            -------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            %Committed Byte In Use         |提交字节占Commit Limit的比率。已提交的虚拟内存实际上是使用中国的物理内存。这部分物理内存已经在页面文件中保留了相应空间，以便在需要写入磁盘时使用。Commit Limit是由页面文件的大小决定的，如果Windows增加了页面文件大小，则Commit Limit也会增加，而这一比率值会随之降低
            Available MBytes               |当前可用的物理内存总量（以MB计数），在数值上等于分配给备用（缓存的）、空闲、零页列表的内存总和，可以立即分配给进程或系统使用。当可用内存小于5%时，系统会变慢，性能也会受到不利影响
            Cache Bytes                    |缓存字节数，在数值上等于系统缓存主驻留字节、系统驱动程序驻留字节、系统代码驻留字节以及换页池驻留字节等计数器的总和。它提供了操作系统内核使用的内存的相关信息。内核内存的关键部分必须存在于物理内存中，而不能在虚拟内存中，其他普通部分可以分布在虚拟内存中
            Cache Bytes Peak               |缓存字节数峰值，系统重启以来文件系统缓存使用的最大字节数
            Cache Faults/sec               |每秒缓存失败次数，在文件系统缓存中无法找到某内存页面，而必须从内存（软失效）或磁盘（硬失效）中其他位置寻找时，称之为缓存失效。文件系统缓存是一块物理内存区域，用于存储应用程序近期使用的页面数据
            Commit Limit                   |以字节计数的虚拟内存总量，无需扩展页面文件就可以提交。随着提交字节数的增多，页面文件可以增加到最大值，此数值可以通过由commit limit减去物理内存总量而获取，如果初始页面文件设置过小，则系统会频繁地扩展页面文件，从而消耗了系统资源。因而，将初始页面大小设置为典型使用情况下的适当值（或者使用固定的页面文件大小）是必要的。
            Commited Bytes                 |已提交的虚拟内存总量（以字节计数）。已提交的虚拟内存实际上是使用中的物理内存。这部分物理内存已经在页面文件中保留了相应空间，用来在需要写入磁盘时使用。每个物理驱动器可以包含一个或多个页面文件，如果系统使用过多的虚拟内存（相对于系统中物理内存总量），则可能需要添加物理内存
            Demand Zero Faults/sec         |零化页面被请求（以满足失效时的需求）的速率，在树枝上等于上两次采样的观测值除以采样间隔。对页面上存储数据进行清空并用0进行填充是Windows的一个安全特性，可以防止进程查看前面进程使用该页面存储的数据
            Free&Zero Page List Bytes      |分配给Free&Zero Page List的物理内存总量（以字节计数）。这块内存不包含缓存数据，可以立即分配给进程或系统使用
            Free System Page Table Entries |系统当前未使用的空闲页面表入口数量
            Modified Page List Bytes       |分配给修改的页面列表的物理内存总量（以字节计数）。修改的页面列表的内存区域包含了进程、系统或系统缓存当前没有活跃的缓存数据与代码，在这块内存区域可以分配给进程或系统之前，Windows不能向其中写入数据
            Page Faults/sec                |每秒钟该页面失效次数，包含硬失效和软失效。软失效后从内存中继续查询，硬失效后则需要访问磁盘
            Page Reads/sec                 |每秒钟为解决硬页面失效而需要的读操作次数。在请求的页面不存在与内存中而必须读取磁盘获取时，就会发生硬页面失效。过多的硬失效会导致极大的延迟，影响系统性能
            Page Writes/sec                |每秒钟页面文件写入到磁盘（以便释放物理内存空间）的次数，只有在页面内容变化时，才需要写入物理内存
            Pages Input/sec                |从磁盘读取页面（以便解决硬页面失效）的速度。在请求的页面不存在于内存中而必须读取磁盘获取时，就会发生硬页面失效。过多的硬失效会导致极大的延迟，影响系统性能
            Pages Output/sec               |页面写入磁盘（以便释放物理内存空间）的速度。如果计算机过于频繁地释放内存，则说明系统物理内存（RAM）不足。
            Pages /sec                     |每秒钟写入磁盘与磁盘读出的页面数。数值上是页面输入/每秒与页面输出/每秒的和
            Pool Non-paged Allocs          |对非换页池中空间进行分配的次数，非换页池是一块用于不能写入磁盘的对象的系统内存区域，一经分配就必须存在于物理内存之中
            Pool Non-paged Bytes           |非换页池的大小（以字节计数），非换页池是一块用于不能吸入磁盘的对象的系统内存区域，一经分配就必须存在于物理内存之中。如果相对于计算机中虚拟内存总量，非换页池比较大，则应该提高虚拟内存大小。如果非换页池大小随时间逐步减小，则说明内核模式进程中可能存在内存泄露问题
            Pool paged Allocs              |在换页池中未分配空间进行的调用的次数。换页池是一块系统内存区域，用于存储那些在不使用时可以写入磁盘的对象
            Pool Paged Bytes               |换页池的总容量（以字节计数）。换页池是一块系统内存区域，用于存储那些在不使用时可写入磁盘的对象。如果换页池容量相对于物理内存总量而言过大，则可能需要为系统添加内存。如果换页池容量随时间逐步增大，则可能内核模式进程在内存在泄露问题
            Pool Paged Resident Bytes      |当前驻留并处于活跃使用状态的换页池容量（以字节计数）。典型情况下，换页池中驻留字节数在树枝上小于分配给换页池的总字节数
            Standby Cache Core Bytes       |分配给核心备用缓存页面列表的物理内存重量（以字节计数），备用缓存页面列表是一块内存区域。其中包含了当前没有被进程、系统或系统缓存活跃使用的缓存数据与代码，可以立即分配给进程或系统使用。如果系统用完可用的free-and-zero内存区域，则低优先级备用缓存页面列表上的内存区域将被重新规划在高优先级备用缓存页面列表上的内存区域之前
            System Cache Resident Bytes    |文件系统缓存中可分页的操作系统代码大小（以字节计数）。该值只包含当前的物理页面，不包含当前未驻留的任何虚拟内存页面
            System Code Resident Bytes     |当前存在于物理内存中的操作系统代码量（以字节计数），不使用时可写入磁盘
            System Code Total Bytes        |当前存在于虚拟内存中的可分页的操作系统代码大小（以字节计数）。该值用于度量操作系统使用过的物理内存（不使用时可以写入磁盘）总量，不包括那些必须驻留在物理内存中（而不能写入磁盘）的代码
            System Driver Resident Bytes   |设备驱动程序当前使用过的可分页物理内存大小（以字节计数）。该部分内存区域是设备驱动程序的working set（工作集，物理内存区域）
            System Driver Total Bytes      |设备驱动程序当前使用的可分页物理内存与虚拟内存大小（以字节计数），包括写入到磁盘的物理内存、代码与数据
            Transition Faults/sec          |页面失效被解决的速度，解决的方法包括：通过由其他进程共享的，或存在于修改的页面列表或备用列表中的，或发生陀失效是正在被写入磁盘的页面进行恢复。页面恢复中不涉及到其他附加的磁盘活动
            Transition Pages Repurposed/sec|Transition缓存页面被冲用于其他目标的速度，如果不进行重用，这些页面本应保存于页面缓存中，重用之后，在被访问时导致软失效。这些页面可以包含私有内存或共享内存
            Write Copies/sec               |页面失效的速度，这里所说的页面特指某些写操作，这些写操作已经被系统通过从物理内存中其他位置进行页面复制而满足
            ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        示例展示了如何使用Typeperf获取内存使用情况的快照。该实例中，使用了一个名为Perf.txt的文件来执行需要追踪的计数器，并以30秒为间隔进行了5次采样，采样结果存储到一个名为SaveData.txt的文件中。如果将此文件导入到电子表格中，或将其转换为Word文档中的表格，就会对输出内容有更好的感知，并对计算机使用内存的方式有准确的理解。
        （注解  选择追踪这些计数器是因为可以获取内存使用情况的一个整体快照，如果将该命令存储位脚本，就可以将其作为一个计划任务，并在每天的不同时间段获取当时内存使用情况快照。）
            示例  获取内存使用情况快照
            Command-line
            typeperf -cf c:\logs\perf.txt -o c:\logs\savedata.txt -sc 5 -si 30

            Source for Perf.txt
            \memory\% Committed Bytes In Use
            \memory\Available MBytes
            \memory\Cache Bytes
            \memory\Cache Bytes Peak
            \memory\Committed Bytes
            \memory\Commit Limit
            \memory\Page Faults/sec
            \memory\Pool Nonpaged Bytes
            \memory\Pool Paged Bytes

            Sample output
            "(PDH-CSV 4.0)","\\SERVER12\memory\% Commited Bytes In Use","
            \\SERVER12\memory\Available MBytes","\\SERVER12\memory\Cache Bytes","
            \\SERVER12\memory\Cache Bytes Peak","\\SERVER12\memory\Committed Bytes","
            \\SERVER12\memory\Commit Limit","\\SERVER12\memory\Page Faults/sec","
            \\SERVER12\memory\Pool Nonpaged Bytes","\\SERVER12\memory\Pool Paged Bytes"

            "03/25/2008 14:24:28.033","22.860837","2023.000000","260632576.000000","
            280514560.000000","1636175872.000000","7157112832.000000","80.494007","
            73240576.000000","152875008.000000"
            "03/25/2008 14:24:30.033","22.861294","2023.000000" "260653056.000000","
            280514560.000000","1636208640.000000","7157112832.000000","70.997253","
            73240576.000000","152875008.000000"
            "03/25/2008 14:24:32.033","22.861294","2023.000000","260653056.000000","
            280514560.000000","1636208640.000000","7157112832.000000","3.000142","
            73261056.000000","152875008.000000"
            "03/25/2008 14:24:34.033","22.861581","2023.000000","260673536.000000","
            280514560.000000","1636229120.000000","7157112832.000000","15 999741","
            73154560.000000","152875008.000000"
            "03/25/2008 14:24:36.033","22.861695","2023.000000","260681728.000000","
            280514560.000000","1636237312.000000","7157112832.000000","6.499981","
            73134080.000000","152875008.000000"
        通过使用Windows PowerShell Get-Process cmdlet，可以获取运行中进程的详细信息。表总结了这一cmdlet的一些关键属性。在Windows PowerShell提示符下，通过如下步骤，可以查看所有进程的重要统计信息。
        （1）获取运行在服务器上所有进程，并将其存储在$a变量中，这是通过如下命令实现的：
            $a = get-process
        （2）使用InputObject参数，将存储在$a变量中的进程对象属性列表传递给format-table cmdlet，这是通过如下命令实现的：
            get-process -inputobject $a | format-table -property ProcessName,
            BasePriority, HandleCount, Id, NonpagedSystemMemorySize,
            PagedSystemMemorySize, PeakPagedMemorySize, PeakVirtualMemorySize,
            PeakWorkingSet, SessionId, Threads, TotalProcessorTime,
            VirtualMemorySize, WorkingSet, CPU, Path
        在逗号分隔的属性列表中，属性的顺序决定了其显示顺序。如果需要改变显示顺序，只需要在该列表中将某属性移动到其他位置。
        实际上，如果确定了需要检查的进程，并不需要使用这种多步骤的复杂过程。只需要输入进程名（不带.exe或.dll后缀），而不需要使用-inputobject $a。下面的实例中，列出了winlogon进程相关的详细资料：
            get-process winlogon | format-table -property ProcessName, BasePriority,
            HandleCount, Id, NonpagedSystemMemorySize, PagedSystemMemorySize,
            PeakPagedMemorySize, PeakVirtualMemorySize, PeakWorkingSet, SessionId,
            Threads, TotalProcessorTime, VirtualMemorySize, WorkingSet, CPU, Path
        (提示  默认请款下，很多用于度量内存使用请款过的属性是以32位值的形式定义的，在64位系统上操作Get-Process时，你会发现这些属性值同时具备32位于64位两个版本。在内存大于4GB的64位系统上，需要使用64位的版本，以便获取准确的属性值。)
            Get-Process的属性及其使用方式
                ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                属性名                                            |属性描述
                --------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                BasePriority                                      |展示进程的优先级。优先级决定了系统资源分配给该进程的优先程度，标准的优先级包括：低（4）、低于标准（6）、标准（8）、高于标准（10）、高（13）、实时（24）。默认情况下，大多数程序的优先级为标准，最高的优先级一般赋予实时进程
                CPU                                               |展示该进程的CPU占用率。System Idle进程展示了CPU资源有多大百分比是空闲的，如果值为99，则说明当前有99%的系统资源处于空闲状态。如果在峰值或平均使用率上系统空闲时间较低（意味着高CPU使用率），则可以考虑升级到更快的处理器或添加处理器
                Description                                       |展示进程的描述信息
                FileVersion                                       |展示进程可执行文件的文件版本
                HandleCount                                       |展示由该进程维护的文件句柄数，该数值描述了该进程对文件系统的依赖程度。有些进程有数千个打开的文件句柄，每个文件句柄都需要一定的系统内存进行维护
                Id                                                |展示该进程的运行时标识数
                MinWorkingSet                                     |展示该进程使用的working set内存的最小总量
                Modules                                           |展示该进程使用的可执行文件与动态链接库
                NonpagedSystemMemorySize/onpagedSystemMemorySize64|展示该进程所拥有的、不允许写入磁盘的虚拟内存总量。这块RAM内存区域也就是非换页池，用于存储那些不能写入到磁盘的对象，对需要很高非换页池容量的对象，应该重点关注。如果服务器没有足够的空闲时间，则这些进程很可能会成为导致大量页失效的根源
                PagedSystemMemorySize/agedSystemMemorySize64      |展示该进程所提交的、可以写入磁盘的虚拟内存总量。这块RAM内存区域也就是换页池，用于存储那些可以在不使用时写入到磁盘的对象。随着进程的不断活动，所需要的内存缓冲池容量也不断增加，大多数进程对换页池的需求超过对非换页池的需求
                Path                                              |展示该进程可执行文件的全路径
                PeakPageMemorySize/PeakPageMemorySize64           |展示该进程使用的页面内存总量的峰值
                PeakVirtualMemorySize/PeakVirtualMemorySize64     |展示该进程使用的虚拟内存总量的峰值
                PeakWorkingSet/PeakWorkingSet64                   |展示该进程使用的内存总量的最大值，包括私有的working set与非私有的working set。如果峰值内存异常大，则可能存在内存泄漏问题
                PriorityBootEnabled                               |显示一个布尔型值，用于表示进程是否激活了PriorityBoost特性
                PriorityClass                                     |显示进程的优先级类别
                PrivilegedProcessorTime                           |显示该进程内核模式使用时间的总量
                ProcessName                                       |显示进程名
                ProcessorAffinity                                 |显示该进程的处理器关联设置
                Responding                                        |显示一个布尔型值，用于表示测试时该进程是否响应
                SessionId                                         |显示运行该进程的用户识别号（会话），对应的是任务管理器中用户选项卡的ID
                StartTime                                         |显示该进程启动的时间与日期
                Threads                                           |显示该进程正在使用的线程数。大多数服务器应用程序都是多线程的，用于处理并发请求，有些应用程序还可以动态控制并发执行的线程数，用来提高应用程序的性能。然而，过多的线程也会降低性能，因为操作系统不得不进行频繁的线程上下文切换
                TotalProcessorTime                                |显示进程启动以来使用的CPU时间总量。如果某进程使用了大量CPU时间，则相关的应用程序可能存在配置问题，也可能表示某个失控进程或失去响应的进程不必要地占用了CPU
                UserProcessorTime                                 |显示进程在用户模式下使用时间的总量
                VirtualMemorySize/VirtualMemorySize64             |显示为某进程分配与保留的虚拟内存总量。虚拟内存是位于磁盘上的内存，在访问速度上慢于缓冲池内存。如果将应用程序配置为使用更多的物理内存，则有助于提高性能。当然，这样做的前提是系统中存在可用的内存，否则会导致系统中运行的其他进程性能下降
                WorkingSet/WorkingSet64                           |显示进程当前正在使用的内存总量，包括私有的working set与非私有的working set，私有的working set是指不能与其他进程共享的内存区域，非私有的working set则可以与其他进程共享。如果某进程的内存使用随时间缓慢增长，并且不再回退到正常值，则可能存在内训泄露问题
                -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    7.1.4终止进程
        如果需要终止运行在本地或远程系统上的进程，可以使用命令行工具Taskkill。通过该工具，可以根据进程ID（使用/Pid参数）或进程镜像名（使用/Im参数）来终止进程。如果需要根据进程ID或进程镜像名来终止进程，则可以输入多个/Pid参数与/Im参数。不过，在使用镜像名是要特别小心，因为Taskkill会终止所有使用该镜像名的进程。因为，如果系统中运行了Heplctr.exe的3个实例，则对该镜像名使用Taskkill之后，所有这3个进程都将被终止。
        与Tasklist类似，默认情况下，Taskkill以当前登录用户的许可权限运行。你也可以指定远程主机（要查询其上的任务）以及Run As许可权限，这是通过使用包含如下一些参数的扩展的语法格式实现的：
            /s Computer /u [Domain\]User [/p Password]
        其中，Computer为远程计算机名或IP地址，Domain为可选的域名，用户账号就存在于该域内，User为用户账号名（要使用的就是该用户账号的许可权限），Password为该用户账号的口令（可选）。如果没有指定域，则系统会假定当前域作为默认的域名。如果没有指定口令，则会弹出提示信息要求输入口令。
        （注解  有时候，强制进程终止运行是必须的。典型情况下，当进程在打开文件、读写数据或执行其他读写操作的过程中停止响应时，就需要强制终止。要强制终止进程，可以使用/F参数，且该参数只适用于本地系统上运行的进程，远程系统上终止的进程通常都是强制终止的。）
        （提示  检查进程时，要记住的是，一个的应用程序可能会启动多个进程。通常，这些进程依赖于一个主进程，并以该主进程为根形成一颗进程树。偶尔，你可能需要终止整个进程树，包括父应用程序进程与所有依赖于该进程的进程。要做到这一点，可以使用/T参数。）
        要了解如何使用Taskkill，参考如下一些实例。
            终止进程ID为208的进程：
                taskkill /pid 208
            终止镜像名为cmd.exe的所有进程
                taskkill /im cmd.exe
            终止Mailer1上进程ID为208、1346、2048的进程：
                taskkill /s Mailer1 /pid 208 /pid 1346 /pid 2048
            强制终止PID为1346的进程：
                taskkill /f /pid 1346
            终止进程树，以PID为1248的进程开始，包括所有子进程：
                taskkill /t /pid 1248
        要确保只终止匹配特定标准的进程，可以使用表中列出的所有过滤器（SessionName除外）。比如，你可以使用过滤器规定只有失去响应的cmd.exe实例才应该终止，而不是终止所有的cmd.exe实例（使用/I参数时，默认情况下是终止所有）。
        与Tasklist类似，Taskkill提供了模块过滤器以及EQ与NE等操作符，用于指定应该包含或排除的DLL。回想一下，Tasklist /M的作用是检查运行中进程与系统中配置的DLL之间的关系。通过使用Taskkill模块过滤器与EQ操作符，可以终止所有使用某特定DLL的进程。通过使用Taskkill模块过滤器与NE操作符，可以确保所有使用某特定DLL的进程不会被终止。
        （提示  使用过滤器时，并不一定需要指定特定的镜像名或进程ID。也就是说，可以只根据进程是否匹配过滤器标准来终止进程。比如，你可以规定只终止所有失去响应的进程。）
        与Tasklist类似，你可以再Taskkill中使用多个过滤器，要记住必须使用双引号封装过滤字符串。要了解如何在Taskkill中使用过滤器，参考如下实例。
            终止失去响应的cmd.exe实例：
                taskkill /im cmd.exe /fi "status eq not responding"
            终止所有PID大于4并且失去响应的进程：
                taskkill /fi "pid gt 4" /fi "status eq not responding"
            终止所有使用Winspool.drv这一DLL的进程：
                taskkill /fi "modules eq winspoll.drv"
        可以看到，尽管第2个实例中没有使用/Im参数与/Pid参数，但对进程ID进行了过滤，从而只影响部分进程。你可能需要避免无意间终止System进程或System Idle进程。典型情况下，这两个进程的PID分别为4和0。如果终止了这两个进程，系统就会停止响应或关机。
7.2通过监控来检测与解决性能问题
    在命令行中，Tasklist与Windows PowerShell Get-Process可以检测与解决大多数性能问题。不过你还是需要进行深入研究，以便发现存在的问题。如果存在问题，就努力找出导致问题的根源。
    7.2.1监控内存分页与磁盘页面
        通常，你可能需要获取关于内存页面硬失效与软失效的详细信息。当某进程请求内存的一个页面，而这个页面不存在于请求的位置时，就会发生页面失效。如果请求的页面内容存在于内存中的某处，就称之为页面软失效。如果请求的页面内容只能从磁盘获取，就称之为页面硬失效。
        如果需要实时查看系统中发生页面失效的情况，可以在命令行中输入如下命令：
            typeperf "\memory\Page Faults/sec" -si 5
        要停止Typeperf，可以按Ctrl+C。页面失效是根据每秒钟硬失效与软失效的次数展示的。其他可用于追踪页面失效的内存对象计数器包括：
            · Cache Faults/sec
            · Demand Zero Faults/sec
            · Page Reads/sec
            · Page Writes/sec
            · Write Copies/sec
            · Transition Faults/se
            · Transition Pages Repurposed/sec
        需要特别关注的是Page Reads/sec与Page Writes/sec这两个计数器，因为这两个计数器提供了页面硬失效的信息。尽管开发人员主要关心的是导致页面失效的根源，但管理员更关心的是发生了多少次页面失效。
        大多数处理器都可以处理大量的软失效，即从内存中其他位置处寻找请求的内存页面。而对于硬失效，则必须从磁盘中取回请求的内存页面，这可能导致很大的延迟。如果系统中发生了大量的硬失效，则可能需要增加系统的内存总量，或者降低系统与应用程序缓存的内存总量。
        除了前面讨论的计数器与内存对象之外，还可以使用下面的对象与计数器来检查磁盘页面问题。
        · Paging File(*)\%Usage。当前使用中该页面文件占总页面文件百分比。如果对所有实例，这一数值都接近100%，则应该考虑增大虚拟内存容量，或者为系统增添物理内存。这将确保计算机有充足的内存资源，以备不时之需（比如计算机工作负载增加的时候）。
        · Paging File(*)\%usage Peak。当前使用中页面文件占可用的总页面文件百分比的峰值。如果这一数值过高，则说明页面文件不够大，不足以处理增加的工作负载需求。
        · PhysicalDisk(*)\%Disk Time。选定磁盘用于处理读写请求所花费的时间。对其上包含页面文件的物理磁盘，应该关注这一数值。如果这一数值在几个检测周期内呈增加趋势，则应该密切关注页面文件使用情况，并考虑为系统增添物理内存。
        · PhysicalDisk(*)\Avg. Disk Queue Length。采样周期内等待选定磁盘处理的平均读写请求次数。对其上包含页面文件的物理磁盘，应该关注这一数值。如果这一数值呈增加趋势，同时Memory\Page Reads/sec也在增加，则说明系统正在处理大量的页面文件读请求。
        上面的描述中，圆括号中的星号是对象实例的占位符。如果某特定对象有多个实例，比如计算机有多个物理磁盘或多个页面文件，则可以使用一个对象实例追踪该对象的特定出现。你也可以追踪某对象的所有实例，比如监控某系统上所有物理磁盘。通过Total，可以操作所有计数器实例，或指定待监控的单独计数器实例。
        示例展示了如何使用Typeperf获取磁盘页面快照，该实例中，使用了一个名为Perf.txt的文件来执行需要追踪的计数器，并以30秒为间隔进行了5次采样，采样结果存储到一个名为SaveData.txt的文件中。如果将此文件导入到电子表格中，或将其转换为Word文档中国的表格，就会对输出内容有更好的了解，并对计算机使用页面文件以及文件分页的方式有准确的理解。
            检查磁盘页面
                Command line
                typeperf -cf c:\logs\pageperf.txt -o c:\logs\savepagedata.txt -sc 5 -si 30

                Source for PagePerf.txt
                \memory\Pages/sec
                \Paging File(_Total)\% Usage
                \Paging File(_Total)\% Usage Peak
                \PhysicalDisk(_Total)\% Disk Time
                \PhysicalDisk(_Total)\Avg.Disk Queue Length
    7.2.2监控单个进程的内存使用与Working Memory Set
        你可以使用Tasklist获取某个进程的基本的内存使用情况，其语法格式为：
            tasklist /fi 'pid eq ProcessID'
        其中，ProcessID为待操作进程的进程ID，输出信息将展示该进程当前使用了多少内存资源。比如，如果待追踪进程PID为7292，则上面命令的输出类似于如下的格式：
            Image Name           PID       Session Name      Session#          Mem Usage
            =================== =====  ====================  ===========     ================
            jvappm.exe           7292                                 1           7424K
        从输出信息可以看出，该进程占用了7424KB内存资源。通过对内存使用请款过的监控，可以判断占用的内存资源是不断增长。如果某进程占用的内存资源找过了典型情况下应该占据的内存资源标准，则该进程可能存在内存相关的问题。
        示例提供了一个命令行脚本源代码，该脚本用于定期检查进程的资源使用情况。运行时，该脚本要求以进程ID为第一个参数。如果没有提供PID，则会返回错误信息。
            示例7-3在命令行中查看内存使用情况
                MemUsage.bat:
                @echo off
                if "%1"=="" (echo Error: please enter Process ID to track) & (goto EXIT)
                tasklist /fi "pid eq %1"
                timeout /t 600
                tasklist /fi "pid eq %1"
                tiemout /t 600
                tasklist /fi "pid eq %1"
                :EXIT

                Sample Output:
                ImageName            PID     SessionName  Session#  MemUsage
                =================== =====  =============  ========  ==========
                jvapm.exe            7292                        1     7452K
                Waiting for 0 seconds,press a key to continue...

                ImageName            PID     SessionName  Session#  MemUsage
                =================== =====  =============  ========  ==========
                jvapm.exe            7292                        1     7452K
                Waiting for 0 seconds,press a key to continue...

                ImageName            PID     SessionName  Session#  MemUsage
                =================== =====  =============  ========  ==========
                jvapm.exe            7292                        1     7452K
        示例中，进程的内存使用更没有随着不同的采样间隔而变化。因为，该进程不太可能存在泄漏问题，但如果要确认这一点，则需要更多次采样。
        你可以使用Windows PowerShell Get-Process cmdlet来追中某进程内存使用请款过的详细信息，其语法格式如下：
            get-process ProcessName | format-table -property
            NonpagedSystemMemorySize, PagedSystemMemorySize, VirtualMemorySize,
            PeakVirtualMemorySize,MinWorkingSet, WorkingSet, PeakWorkingSet
        其中，ProcessName为进程名（不带.exe或.dll后缀）。在Windows PowerShell脚本中，如示例，可以将Get-Process cmdlet与start-sleep cmdlet结合起来，以便在定时的时间间隔查看某进程的内存使用情况。
            示例7-4查看内存使用情况的详细信息
                MemUsage.ps1:
                get-process msdtc | format-table -property NonpagedSystemMemorySize,
                PagedSystemMemorySize, VirtualMemorySize, PeakVirtualMemorySize,
                MinWorkingSet, WorkingSet, PeakWorkingSet

                start-sleep -seconds 600

                get-process msdtc | format-table -property NonpagedSystemMemorySize,
                PagedSystemMemorySize, VirtualMemorySize, PeakVirtualMemorySize,
                MinWorkingSet, WorkingSet, PeakWorkingSet

                start-sleep -seconds 600
                get-process msdtc | format-table -property NonpagedSystemMemorySize,
                PagedSystemMemorySize, VirtualMemorySize, PeakVirtualMemorySize,
                MinWorkingSet, WorkingSet, PeakWorkingSet

                Sample Output:
                Nonpaged         PagedSystem    Virtual        Peak           Working       Peak
                System           Memory         Memory         Virtual        Set           Wokring
                MemorySize       Size           Size           MemorySize                   Set
                ---------------  -------------  -------------  -------------  ------------  ----------
                6304             70544           41766912       63631360       6287360       6344704

                Nonpaged         PagedSystem    Virtual        Peak           Working       Peak
                System           Memory         Memory         Virtual        Set           Wokring
                MemorySize       Size           Size           MemorySize                   Set
                ---------------  -------------  -------------  -------------  ------------  ----------
                8123             96343          56243535       97423424       9147256       9348942

                Nonpaged         PagedSystem    Virtual        Peak           Working       Peak
                System           Memory         Memory         Virtual        Set           Wokring
                MemorySize       Size           Size           MemorySize                   Set
                ---------------  -------------  -------------  -------------  ------------  ----------
                17564            129645          48934246       97423424       9987384       10344706
        （注解  Windows PowerShell脚本文件的扩展名为.ps1，要在Windows PowerShell提示符中运行脚本，需要键入脚本名以及可选的扩展名，要注意的是，必须指定脚本文件的全路径，即便脚本文件在当前目录下。要指定当前目录，可以使用目录名或圆点符号（.）。比如，对于当前目录下的MemUsage.ps1文件，可以在Windows PowerShell提示符中键入.\memusage.ps1来运行该脚本。）
        示例中，Get-Process提供了如下一些信息。
        · NonPagedSystemMemorySize。展示了不能写入磁盘的已分配内存总量。
        · PagedSystemMemorySize。展示了可以与磁盘进行页面交换的已分配内存总量。
        · VirtualMemorySize。展示了为某进程分配与保留的虚拟内存总量。
        · PeakVirtualMemorySize。展示了某进程使用的虚拟内存总量峰值。
        · WorkingSetSize。展示了操作系统分配给进程的内存总量。
        · PeakWorkingSet。展示了进程使用的内存总量峰值。
        关注这些属性是，实际上是聚集于某个特定进程的内存使用情况。要监控的关键内容是working memory set，指的是操作系统为该进程分配的内存。如果该数值随时间增长，而最终不能回退到正常情况下的标准值，则该进程可能存在内存泄露问题。发生内存泄漏时，进程无法正常释放占用的内存，从而导致系统整体性能下降。
        示例中，进程的内存使用随着采样间隔不断增加，最可能的原因是该进程正被用户或计算机本身活跃地使用。正常的话，该进程的内存使用会回归到一个标准值。如果不能，则说明该进程可能存在内存相关的问题。
    7.2.3解决性能瓶颈
        由于内存是工作站与服务器上的主要性能瓶颈，本章前面讨论的很多技术都有助于确定系统中存在的内存相关问题。在系统不能正常运行时，内存应该是第一个检查的目标。
        然而，内存并不是唯一的性能瓶颈，处理器也可能会成为系统新能的瓶颈。比如，进程的多线程需要的CPU时间超过了可用的CPU资源。如果处理器成为系统性能瓶颈，则增加内存、驱动器或网络带宽都不能解决问题。只能对处理器密集型的应用程序转移到其他服务器上运行。
        可用于检查处理器瓶颈的Typeperf计数器包括如下5个。
        · System\Processor Queue Length。记录等待执行的线程数。这些进程在一块由系统中所有处理器共享的区域中排队等待执行，由于线程在执行之前必须等待。因此，处理器队列是逐渐增长的，从而导致系统响应变慢，甚至失去响应。为避免这种情况，需要对处理器进程升级（更快的主频），或者添加处理器，来提高服务器的性能上限。
        · Processor(*)\% Processor Time。记录
