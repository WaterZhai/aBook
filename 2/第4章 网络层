第4章   网络层

本章讨论网络互连问题，也就是谈论对个网络通过路由器互连成为一个互连网络（或互联网）的各种问题。在介绍网路层提供的两种不同的服务后，就进入本章的核心内容--网际协议IP，这是本书的一个重点内容。只有较深入地掌握了IP协议的主要内容，才能理解因特网是怎样工作的。本章还要讨论网际控制报文协议ICMP和几种常用的路由选择协议，以及IP多播的概念。最后简要地介绍虚拟专用网VPN和网络地址转换NAT。
    本章最重要的内容是：
        1）虚拟互联网络的概念；
        2）IP地址与物理地址的关系；
        3）传输的分类IP地址（包括子网掩码）和无分类域间路由选择CIDR；
        4）路由选择协议的工作原理。
4.1网络层提供的两种服务
    在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统？
    有些人认为应当借助于电信网的成功经验，让网络负责可靠交付。大家知道，传统电信网的主要业务是提供电话服务。电信网使用昂贵的程控交换机（其软件也非常复杂），用面向连接的通信方式，使电信网络能够向用户（实际上就是电话机）提供可靠传输的服务。因此他们任务，计算机网络也应模仿打电话所使用的面向连接的通信方式。当两个计算机进行通信时，也应当先建立连接（但在分组交换中是建立一条虚电路VC（Virtual Circuit））,以保证双方通信所需的一切网络资源。然后双方就沿着已建立的虚电路发送分组。这样的分组的首部不需要填写完整的目的主机地址，而只需要填写这条虚电路的编号（一个不大的整数），因而减少了分组的开销。这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序列到达终点，淡然也不丢失、不重复。在通信结束后要释放建立的虚电路。
    但因特网的先驱者却提出一种崭新的网络设计思路。他们认为，电信网提供的端到端可靠传输的服务对电话业务无疑是很合适的，因为电信网的终端（电话机）非常简单，没有智能，无差错处理能力。因此电信网必须负责把用户电话机产生的话音信号可靠地传送到对方的电话机，使还原后的话音质量符合技术规范的yaoqiu.dan计算机网络的端系统是有智能的计算机。计算机有很强的差错处理的能力（这点和电话机本质上的差别）。因此，因特网在设计上就采用了和电信网完全不同的思路。
    因特网采用的设计思路是这样的：网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络在发送分组时不需要先建立连接。每一个分组（也就是IP数据报）独立发送，与其前后的分组无关（不进行编号）。网络层不提供服务质量的承诺。也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点），当然也不保证分组交付的时限。由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做的比较简单，而且价格低廉（与电信网的交换机相比较）。如果主机（即端系统）中的进程之间的通信需要时可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够使用多种应用。因特网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。
    OSI体系的支持者曾极力主张在网络层使用虚电路服务。他们也曾推出过网络层虚电路服务的著名标准--ITU-T的X.25建议书。但现在X.25早已成为历史了。
        虚电路服务于数据报服务的对比
        ---------------------------------------------------------------------------------------------------------------
        |对比的方面              |虚电路服务                                  |数据报服务                                 |
        ----------------------------------------------------------------------------------------------------------------
        |思路                   |可靠通信应当由网络来保证                     |可靠通信应当由用户主机来保证                 |
        ----------------------------------------------------------------------------------------------------------------
        |连接的建立              |必须有                                     |不需要                                     |
        ----------------------------------------------------------------------------------------------------------------
        |终点地址                |仅在连接建立阶段使用，每个分组使用短的虚电路号|每个分组都有终点的完整地址                    |
        ----------------------------------------------------------------------------------------------------------------
        |分组的转发              |属于同一条虚电路的分组均按照统一路由进行转发  |每个分组独立选择路由进行转发                  |
        ----------------------------------------------------------------------------------------------------------------
        当结点出故障时           |所有通过故障的结点的虚电路均不能工作          |出故障的结点可能丢失分组，一些路由可能会发生变化|
        -----------------------------------------------------------------------------------------------------------------
        |分组的顺序              |总是按发送顺序到达终点                       |到达终点时不一定按发送顺序                    |
        ------------------------------------------------------------------------------------------------------------------
        |端到端的差错处理和流量控制|可以由网络复杂，也可以由用户主机负责          |有用户主机负责                               |
        ------------------------------------------------------------------------------------------------------------------

    鉴于TCP/IP体系的网络层提供的是数据报服务，因此下面我们的讨论都是围绕网络层如何传送IP数据报这个主题。
4.2网际协议IP
    网际协议IP是TCP/IP体系中两个最主要的协议之一，也是最重要的因特网标准协议之一。与IP协议配套使用的还有四个协议：
        ·地址解析协议ARP（address Resolution Protocol）
        ·逆地址解析协议RARP（Reverse Address Resolution Protocol）
        ·网际控制报文协议ICMP（Internet Control Message Protocol）
        ·网际组管理协议IGMP（Internet Group Management Protocol）
    四个协议和网际协议IP的关系：
        应用层    |各种应用层协议（HTTP，FTP，SMTP等）
        ---------------------------------------
        运输层    |TCP，UDP
        ---------------------------------------
        网络层    |ICMP、IGMP
                  |            IP
                  |                RARP、ARP
        ---------------------------------------
        网络接口层|与各种网路接口
        ---------------------------------------
        在这一层中，ARP和RARP在最下面，因为IP经常要使用这两个协议。ICMP和IGMP在这一层的上部，因为它们要使用IP协议。这四个协议将在后面陆续介绍。由于网际协议IP是用来使互连起来的许多计算机网络能够进行通信，因此TCP/IP体系中的网络层常常称为网际层（internet layer），或IP层。
        在讨论网际协议IP之前，必须了解什么是虚拟互联网络。
    4.2.1虚拟互联网络
        我们知道，如果要在全世界范围内把数以百万计的网络都互连起来，并且能够互相通信，那么这样的任务一定非常复杂。其中会遇到许多问题需要解决，如：
            ·不同的寻址方案
            ·不同的最大分组长度
            ·不同的网络接入机制
            ·不同的超时控制
            ·不同的差错恢复方法
            ·不同的状态报告方法
            ·不同的路由选择技术
            ·不同的用户接入控制
            ·不同的服务（面向连接服务和无连接服务）
            ·不同的管理与控制方式；等等。
        能不能让大家是用相同的网络，这样可是网络互连变得比较简单。答案是不行的。因为用户的需求是多种多样的，没有一种单一的网络能够适应所有用户的需求。另外网络技术是不断发展的，网络的制造厂家也要经常推出新的网络，在竞争中求生存。因此在市场上总是有很多种不同性能、不同网络协议的网络，供不同的用户选用。
        从一般的概念来讲，将网络互相连接起来要使用一些中间设备。根据中间设备所在的层次，可以有以下四种不同的中间设备：
            1）物理层使用的中间设备叫做转发器（repeater）。
            2）数据链路层使用的中间设备叫做网桥或桥接器（bridge）。
            3）网络层使用的中间设备叫做路由器（router）。
            4）在网络层以上使用的中间设备叫做网关（gateway）。用网关连接两个不兼容的系统需要在高层进行协议的转换。
        当中间设备是转发器或网桥时，这仅仅是把一个网络扩大了，而从网络层的角度看，这仍然是一个网络，一般并不称之为网络互连。网关由于比较复杂，目前使用得较少。因此现在我们讨论网络互连时都是指用路由器进行网络互连和路由选择。路由器其实就是一台专用计算机，用来在互联网中进行路由选择。由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器称为网关（在本书中，有时也这样用）。对此请读者加一注意。
        TCP/IP体系在网络互连上采用的做法是在网路层（即IP层）采用了标准化协议，但相互连接的网络则可以是异构的。有许多计算机网络通过一些路由器进行互连。由于参加互连的计算机网络都使用相同的网际协议IP（Internet Protocol），因此可以把互连以后的计算机网络看成一个虚拟互联网络（internet）。所谓虚拟互联网络也就是逻辑互联网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用IP协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。
        这种使用IP协议的虚拟互联网络可简称为IP网（IP网是虚拟的，但平常不必每次都强调“虚拟”二字）。使用IP网的好处是：当IP网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节（如具体的编织方案、路由选择协议，等等）。
        当很多异构网络通过路由器互连起来时，如果所有的网络都使用相同的IP协议，那么在网络层讨论问题就显得很方便。现在用一个例子来说明。
        互联网中的源主机H1要把一个IP数据报发送给目的主机H2.根据第1章中讲过的分组交换的存储转发概念，主机H1先要查找自己的路由表，看目的主机是否就在本网络上。如是，则不需要经过任何路由器而是直接交付，任务就完成了。如不是，则必须把IP数据报发送给某个路由器（R1）。R1在查找了自己的路由表后，知道应把数据报转发给R2进行间接交付。这样一直转发下去，最后由路由器R5知道自己是和H2连接在同一个网络上，不需要再使用别热路由器转发了，于是就把数据报直接交付给目的主机H2。源主机、目的主机以及各路由器的协议栈。我们注意到，主机的协议栈共有五层，但路由器的协议栈只有下三层。在R4和R5之间使用了卫星链路，而R5所连接的是个无线局域网。在R1到R4之间的三个网络则可以是任意类型的网络。总之，这里强调的是：互联网可以由多种异构网络互联组成。
        如果我们只从网络层考虑问题，那么IP数据报就可以想象是在网络层中传送。这样就不必画出许多完成的协议栈，使问题的讨论更加简单。
        有了虚拟互联网络的概念后，再讨论在这样的虚拟网络上如何寻址。
    4.2.2分类的IP地址
        在TCP/IP体系中，IP地址是一个最基本的概念，一定要把它弄清楚。有关IP最重要的文档就是REC791，它很早就成了因特网的正式标准。
        1.IP地址及其表示方法
        整个的因特网就是一个单一的、抽象的网络。IP地址就是给因特网上的每一个主机（或路由器）的每一个接口分配一个在全世界范围是唯一的32位的标识符。IP地址的结构使我们可以在因特网上很方便地进行寻址。IP地址现在在由因特网名字与号码指派公司ICANN（Internet Corporation for Assigned Names and Numbers）进行分配。
        IP地址的编织方法共经过了三个历史阶段。这三个阶段是：
            1）分类的IP地址。这是最基本的编制方法，在1981年就通过了相应的标准协议。
            2）子网的划分。这是对最基本的编址方法的改进，其标准RFC950在1985年通过。
            3）构成超网。这是比较新的五分类编址方法。1993年提出后很快就得到推广应用。
        本节只讨论最基本的分类IP地址。后两种方法将在4.3节中讨论。
        所谓“分类的IP地址”就是将IP地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，其中第一个字段是网络号（net-id），它标志主机（或路由器）所连接到的网络。一个网络号在整个因特网范围内必须是唯一的。第二个字段是主机号（host-id），它标志该主机（或路由器）。一个主机号在他前面的网络号所指明的网络范围内必须是唯一的。由此可见，一个IP地址在整个因特网范围内是唯一的。
            这种两级的IP地址可以记为：
                              IP地址::={<网络号>,<主机号>}
            上式中的“::=”便是“定义为”。各种IP地址的网络号字段和主机号字段，这里A类、B类和C类地址都是单薄地址（一对一通信），是最常用的。
                ·A类、B类和C类地址的网络号字段分别为1，2，和3字节长，而在网络号字段的最前面有1-3位的类别位，其数值分别规定为0，10和110。
                ·A类、B类和C类地址的主机号字段分别为3个、2个和1个字节长。
                ·D类地址（前4位是1110）用于多播（一对多通信）。我们将在4.6节讨论IP多播。而E类地址（前4位是1111）保留为以后用。
            这里要指出，由于近年来已经广泛使用无分类IP地址进行路由选择，A类、B类和C类地址的区分已经成为历史，但由于很多文献和资料都还使用传统的分类IP地址，因此我们在这里还要从分类IP地址讲起。
            从IP地址的结构来看，IP地址并不仅仅指明一个主机，而是还指明了主机所连接到的网络。
            把IP地址划分为三个类别，当初是这样考虑的。各种网络的差异很大，有的网络拥有很多主机，而有的网络上的主机则很少。把IP地址划分为A类、B类和C类是为了更好地满足不同用户的要求。当某个单位申请到一个IP地址时，实际上是获得了具有同样网络号的一块地址。其中具体的各个主机号则由该单位自行分配，只要做到在该单位管辖的范围内无重复的主机号即可。对主机或路由器来说，IP地址都是32位的二进制代码。为了提高可读性，我们常常把32位的IP地址中的每8位用其等效的十进制数字表示，并且在这些数字之间加上一个点。这就叫做点分十进制记法（dotted decimal notation）。一个B类IP地址。显然，128.11.3.31比10000000 00001011 00000011 00011111读起来要方便得多。
        2.常用的三种类别的IP地址
        A类地址的网路号字段占一个字节，只有7位可供使用（该字段的第一位已固定为0），但可指派的网络号是126个（即2^7-2）。减2的原因是：第一，IP地址中的全0表示“这个（this）。”网络号字段为全0的IP地址是个保留地址，意思是“本网络”。第二，网络号为127（即01111111）保留作为本地软件环回测试（loopback test）本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如127.0.0.1）的IP数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的IP数据报永远不会出现在任何网络上，因为网路号为127的地址根本不是一个网络地址。
        A类地址的主机号占3字节，因此每一个A类网络中最大主机数是2^24-2，即16777214.这里减2的原因是：全0的主机号字段表示该IP地址是“本主机”所连接到的单个网络地址（例如，一主机的IP地址为5.6.7.8，则该主机所在的网络地址就是5.0.0.0），而全1表示“所有的（all）”，因此全1的主机号字段表示该网络上的所有主机。
        IP地址空间共有2^32（即4294967296）个地址。整个A类地址空间共有2^31个地址，占有整个IP地址空间的50%。
        B类地址的网络号字节由2字节，但前面两位（10）已经固定了，只剩下14位可以进行分配。因为网络号字段后面的14位无论怎样取值也不可能出现使整个2字节的网络号字段成为全0或全1，因此这里不存在网络总数减2的问题。但实际上B类网络地址128.0.0.0是不指派的，而可以指派的B类最小网络地址是128.1.0.0.因此B类地址可指派的网络数为2^14-1，即16383.B类地址的每一个网络上的最大主机数是2^16-2，即65534.这里需要减2是因为要扣除全0和全1的主机号。整个B类地址空间共约有2^30个地址，占整个IP地址空间的25%。
        C类地址有3个字节的网路号字段，最前面的3位是（110），还有21位可以进行分配。C类网络地址192.0.0.0也是不指派的，可以指派的C类最小网络地址是192.0.1.0，因此C类地址可指派的网络总数是2^21-1，即2097151.每一个C类地址的最大主机数是2^8-2，即254.整个C类地址空间共约有2^29个地址，占整个IP地址的12.5%。
            这样，我们就可得出表所示的IP地址的指派范围。
            ----------------------------------------------------------------------------------------
            |网络类别|最大可指派的网络数|第一个可指派的网络号|最后一个可指派的网络号|每个网络中的最大主机数|
            ----------------------------------------------------------------------------------------
            |A      |126（2^7-2）     |1                  |126                 |16777214           |
            ----------------------------------------------------------------------------------------
            |B      |16383（2^14-1）  |128.1              |191.255             |65534              |
            ---------------------------------------------------------------------------------------
            |C      |2097151（2^21-1）|192.0.1            |223.255.255         |254                |
            ----------------------------------------------------------------------------------------
            一般不实用的IP地址，这些地址只能在特定的情况下使用。
            ------------------------------------------------------------------------------------
            |网络号|主机号           |源地址使用|目的地址使用|代表的意思                           |
            ------------------------------------------------------------------------------------
            |0     |0                |可以     |不可       |在本网络上的本主机（见6.6节的DHCP协议）|
            ------------------------------------------------------------------------------------
            |0     |host-id          |可以     |不可       |在本网络上的某个主机host-id           |
            ------------------------------------------------------------------------------------
            |全1   |全1              |不可      |可以      |只在笨网络上进行广播（各路由器均不转发）|
            ------------------------------------------------------------------------------------
            |net-id|全1              |不可      |可以      |对net-id上的所有主机进行广播          |
            ------------------------------------------------------------------------------------
            |127   |非全0或全1的任何数|可以      |可以      |用作本地软件环回测试之用              |
            ------------------------------------------------------------------------------------

        IP地址具有以下一些重要特点：
            1）每一个IP地址都由网络号和主机号两部分组成。从这个意义上说，IP地址是一种分等级的地址结构。分两个等级的好处是：第一，IP地址管理机构在分配IP地址时只分配网络号（第一级），而剩下的主机号（第二级）则由得到该网络号的单位自行分配。这样就方便了IP地址的管理。第二路由器仅根据目的主机所连接的网络号来转发分组（而不考虑主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间以及查找路由表的时间。
            2）实际上IP地址是标志一个主机（或路由器）和一条链路的接口。当一个主机同时连接到两个网络上，该主机就必须同时具有两个相应的IP地址，其网络号必须是不同的。这种主机称为多归属主机（multihomed host）。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的IP地址。
            3）按照因特网的观点，一个网络是指具有相同网络号net-id的主机的集合，因此，用转发器或网桥连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。
            4）在IP地址中，所有分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网）都是平等的。
        三个局域网（LAN1、LAN2和LAN3）通过三个路由器（R1、R2和R3）互连起来构成的一个互联网（此互联网用虚线圆角方框表示）。其中局域网LAN2是由两个网段通过网桥B互连的。
        我们应当注意到：
            1）在同一个局域网上的主机或路由器的IP地址中的网络号必须是一样的。网络号就是IP地址中的网络号字段的值，这也是文献中常见的一种表示方法。另一种表示方法使用主机号为全0的网络IP地址。
            2）用网桥（它只在链路层工作）互连的网段仍然是一个局域网，只能有一个网络号。
            3）路由器总是具有两个或两个以上的IP地址。即路由器的每一个接口都有一个不同网络号的IP地址。
            4）当两个路由器直接相连是（例如通过一条租用线路），在连线两端的接口处，可以分配也可以不分配IP地址。如分配了IP地址，则这一段连线就构成了一种只包含一段线路的特殊“网络”（如图中的N1，N2和N3）。之所以叫做“网络”是因为它有IP地址。但为了节省IP地址资源，对于这种仅有一段连线构成的特殊“网络”，现在也常常不分配IP地址。通常把这样的特殊网络叫做无编号网络（unnumbered network）或无名网络（anonymous network）。
    4.2.3IP地址与硬件地址
        在学习IP地址时，很重要的一点就是要弄懂主机的IP地址与硬件地址的区别。
        这两种地址的区别。从层次的角度看，物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址（称为IP地址是逻辑地址是因为IP地址使用软件实现的）。
                      |首部|应用层数据 |
                      |----TCP报文----|
                 |首部|               |
                 |----  IP数据报  ----|
            |首部|                    |尾部|
            |----        MAC帧         ----|
            数据链路层使用硬件地址；网络层及以上使用IP地址
        在发送数据时，数据从高层下到底层然后才到通信链路上传输。使用IP地址的IP数据报一旦交给了数据链路层，就被封装成MAC帧了。MAC帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在MAC帧的首部中。
        连接在通信链路上的设备（主机或路由器）在接收MAC帧时，其根据是MAC帧首部中的硬件地址。在数据链路层看不见隐藏在MAC帧的数据中的IP地址。只有在剥去MAC帧的首部和尾部后把MAC层的数据上交给网络层后，网络层才能在IP数据报的首部中找到源IP地址和目的地址。
        总之，IP地址放在IP数据报的首部，而硬件地址则放在MAC帧的首部。在网络层和网络层以上使用的是IP地址，而数据链路层及以下使用的是硬件地址。当IP数据报放入数据链路层的MAC帧中以后，整个的IP数据报就成为MAC帧的数据，因而在数据链路层看不见数据报的IP地址。
        三个局域网用两个路由器R1和R2互连起来。现在主机H1要和主机H2通信。这两个主机的IP地址分别是IP1和IP2，而它们硬件地址分别为HA1和HA2（HA表示Hardware Address）。通信的路径是：H1->经过R1转发->再经过R2转发->H2.路由器R1因同时连接到两个局域网上，因此它有两个硬件地址，即HA3和HA4.同理，路由器R2也有两个硬件地址HA5和HA6.
        这里要强调指出的是：
            1）在IP层抽象的互联网上只能看到IP数据报。虽然IP数据报要经过路由器R1和R2的两次转发，但在它的首部中的源地址和目的地址始终分别是IP1和 IP2。数据报上写的“从IP1到IP2”就表示前者是源地址而后者是目的地址。数据报中间经过的两个路由器的IP地址并不出现在IP数据报的首部中。
            2）虽然在IP数据报首部有源站IP地址，但路由器值根据目的站的IP地址的网络号进行路由选择。
            3）在局域网的链路层，只能看见MAC帧。IP数据报被封装在 MAC帧中。MAC帧在不同网络上传送时，其MAC帧首部中的源地址和目的地址要发生变化。开始在H1到R1间传送时，MAC帧首部中写的是从硬件地址HA1发送到硬件地址HA3，路由器R1收到此MAC帧后，在转发时要改变首部中的源地址和目的地址，将它们换成从硬件地址HA4发送到硬件地址HA5.路由器R2收到此帧后，再改变一次MAC帧的首部，填入从HA6发送到 HA2ranhou在R2到H2之间传送。 MAC帧的首部的这种变化，在上面的IP层上也是看不见的。
            4）尽管互连在一起的网络的硬件地址体系各不相同，但IP层抽象的互联网却屏蔽了下层这些很复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机和主机或路由器之间的通信。上述这种“屏蔽”概念是一个很有用、很普遍的基本概念。例如，计算机中广泛使用的图形用户界面使得用户只需要简单地点击几下鼠标就能让电脑完成很多任务。实际上电脑要完成这些任务必须执行很多条指令。但这些复杂的过程全被设计良好的图形用户界面屏蔽掉了，使用户看不见这些复杂过程。
            以上这些概念是计算机网络的精髓所在，对这些重要概念务必仔细思考和掌握。
        细心的读者会发现，还有两个重要问题没有解决：
            1）主机或路由器怎样知道应当在MAC帧的首部填入什么样的硬件地址？
            2）路由器中的路由表是怎样得出的？
            第一个问题就是下一节所要将的内容，而第二个问题将在后面4.5节详细讨论。
    4.2.4地址解析协议ARP和逆地址解析协议RARP
        在实际应用中，我们经常会遇到这样的问题：已经知道了一个机器（主机或路由器）的IP地址，需要找出其相应的物理地址；或反过来，已经知道了物理地址，需要找出相应的IP地址。地址解析协议ARP和逆地址解析协议RARP就是用来解决这样的问题的。
        这两种协议的作用：
            IP地址===>|ARP|===>物理地址
            物理地址===>|RARP|===>IP地址
        逆地址解析协议RARP在过去曾起到重要作用。但现在的DHCP协议（见第6章的6.6节）已经包含了RARP协议的功能。因此现在已经没有人再使用单独的RARP协议了。因此这里不再进一步介绍RARP协议。我们只需要了解，逆地址解析协议RARP的作用是只知道自己硬件地址的主机能够通过RARP协议找出其IP地址。
            下面就介绍ARP协议的要点。
        我们知道，网络层使用的是IP地址，但在实际网络的链路上传送数据帧时，最终还是必须使用该网络的硬件地址。但IP地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系(例如，IP地址有32位，而局域网的硬件地址是48位)。此外，在一个网络上可能经常会有新的主机加入进来，或撤走一些主机。更换网络适配器也会使主机的硬件地址改变。地址解析协议ARP解决这个问题的方法是在主机ARP高速缓存中应存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新（新增或超市删除）。
        每一个主机都没有一个ARP高速缓存（ARPcache），里面有本局域网上的个主机和路由器的IP地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。那么主机怎样知道这些地址呢？我们可以通过下面的例子来说明。
        当主机A要向本局域网上的某个主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址。如有，就在ARP高速缓存中查出其对应额硬件地址，再把这个硬件地址写入MAC帧，然后通过局域网把该MAC帧发往此硬件地址。
        也有可能查不到主机B的IP地址的项目。这可能是主机B才入网，也可能是主机A刚刚加电，其高速缓存还是空的。在这种情况下，主机A就自动运行ARP，然后按一下步骤找出主机B的硬件地址。
        1）ARP进程在本局域网上广播发送一个 ARP请求分组（集体格式可参阅例如附录C中的第23章）。主机A广播发送ARP请求分组。ARP请求分组的主要内容是表明：“我的IP地址是209.0.0.5，硬件地址是00-00-C0-15-AD-18.我想知道IP地址为209.0.0.6的主机的硬件地址。”
        2）在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组。
        3）主机B在ARP请求分组中见到自己的IP地址，就向主机A发送ARP响应分组，并写入自己的硬件地址。其余的所有主机都不理睬这个ARP请求分组。ARP响应分组的主要内容是表明：“我的IP地址是209.0.0.6，我的硬件地址是08-00-2B-00-EE-0A。”请注意：虽然ARP请求分组是广播发送的，但ARP响应分组是普通的单播，即从不一个源地址发送到一个目的地址。
        4）主机A收到主机B的ARP响应分组，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。
        当主机A向B发送数据报时，很可能以后不久主机B还要向A发送数据报，因而主机B也可能要向A发送ARP请求分组。为了减少网络上的通信量，主机A在发送其ARP请求分组时，就把自己的IP地址到硬件地址的映射写入ARP请求分组。当主机B收到A的ARP请求分组时，就把主机A的这一地址映射写入主机B自己的ARP高速缓存中。以后主机B向A发送数据报时就很方便了。
        可见ARP高速缓存非常有用。如果不使用ARP高速缓存，那么任何一个主机只要进行一次通信，就必须在网络上用广播方式发送ARP请求分组，这就使网络上的通信量大大增加。ARP把已经得到的地址映射保存在高速缓存中，这样就使得该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再用广播方式发送ARP请求分组。
        ARP把保存在高速缓存中的每一个映射地址项目都设置生存时间（例如，10~20分钟）。凡超过生存时间的项目就从高速缓存中删除掉。设置这种地址映射的生存时间是很重要的。设想有一种情况。主机A和B通信。A的ARP高速缓存里保存有B的物理地址。但B的网络适配器突然坏了，B立即更换了一块，因此B的硬件地址就改变了。假定A还要和B继续通信。A在其ARP高速缓存中查找到B原先的硬件地址，并使用该硬件地址向B发送数据帧。但B原先的硬件地址已经失效了，因此A无法找到主机B。但是过了一段不长时间，A的ARP高速缓存中已经删除了B原先的硬件地址（因为他的生存时间到了），于是A重新广播发送ARP请求分组，又找到了B。
        请注意，ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，例如，主机H1就无法解析出主机H2的硬件地址（实际上主机H1也不需要知道远程主机H2的硬件地址）。主机H1发送给H2的IP数据报首先需要通过与主机H1连接在同一个局域网上的路由器R1来转发。因此主机H1这时需要把路由器R1的IP地址IP3解析为硬件地址HA3，以便能够把IP数据报传送到路由器R1.以后，R1从转发表找出了下一跳路由器R2，同时使用ARP解析出R2的硬件地址HA5.于是IP数据报按照硬件地址HA5转发到路由器R2.路由器R2在转发这个IP数据报时用类似方法解析出目的主机H2的硬件地址HA2，使IP数据报最终交付给主机H2.
        从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。只要主机或路由器要和本网络上的另一个已知IP地址的主机或路由器进行通信，ARP协议就会自动地把这个IP地址解析为链路层所需要的硬件地址。
            下面我们归纳使用ARP的四种典型情况。
            1）发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用ARP找到目的主机的硬件地址。
            2）发送方是主机，要把IP数据报发送到另一个网络上的一个主机。这时用ARP找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。
            3）发送方是路由器，要把IP数据报转发到本网络上的一个主机。这时用ARP找到目的主机的硬件地址。
            4）发送方是路由器，要把IP数据报转发到另一个网络上的一个主机。这时用ARP找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。
        在许多情况下需要多次使用ARP。但这只是以上的几种情况的反复使用而已。
        有的读者可能会产生这样的问题：既然在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么我们不直接使用硬件地址进行通信，而是要使用抽象的IP地址并调用ARP来寻找出相应的硬件地址呢？
        这个问题必须弄清楚。
        由于全世界存在着各种各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但统一的IP地址把这个复杂问题解决了。连接到因特网的主机只需拥有统一的IP地址，它们之间的通信就像连接在同一网络上那样简单方便，因为上述的调用ARP的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。
        因此，在虚拟的 IP网络上用IP地址进行通信给广大的计算机用户带来很大的方便。
    4.2.5IP数据报的格式
        IP数据报的格式能够说明IP协议都具有什么功能。在TCP/IP的标准中，各种数据格式常常以32位（即4字节）位单位来描述。
        一个IP数据报由首部和数据两部分组成。首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的。在首部的固定部分的后面使一些可选字段，其长度是可变的。下面介绍首部各字段的意义。
            1.IP数据报首部的固定部分中的各字段
                1）版本    占4位，指IP协议的版本。通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4（即IPv4）。关于以后要使用的IPv6（即版本6的IP协议），我们将在第10章的10.1节讨论。
                2）首部长度    占4位，可表示的最大十进制数值是15.请注意，这个字段所表示数的单位是32位字（1个32位字长是4字节），因此，当IP的首部长度为1111时（即十进制的15），首部长度就达到最大值60字节。当IP分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在4字节的整数倍时开始，这样做是实现IP协议时较为方便。首部长度限制为60字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是20字节（即首部长度为0101），这时不使用任何选项。
                3）区分服务    占8位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998年IETF把这个字段改名为区分服务DS（Differentiated Services）。只有在使用区分服务时，这个字段才起作用（见8.4.4节）。在一般情况下都不使用这个字段。
                4）总长度   总长度指首部和数据之和的长度，单位为字节。总长度字段为16位，因此数据报的最大长度为2^16-1=65535字节。
                在IP层下面的每一种数据链路层都有其自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元MTU（MaximumTransgerUnit）。当一个IP数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的MTU值。
                虽然使用尽可能长的数据报会使传输效率提高，但由于以太网的普遍应用，所以实际上使用的数据报长度很少有超过1500字节的。为了不使IP数据报的传输效率降低，有关IP的标准文档规定，所有的主机和路由器必须能够处理的IP数据报长度不得小于576字节。这个数值也就是最小的IP数据报的总长度。当数据报长度超过网络所容许的最大传送单元MTU时，就必须把过长的数据报进行分片后才能在网络上传送（见后面的“片偏移”字段）。这时，数据报首部中的“总长度”字段不是指为分片前的数据报长度，而是指分片后的每一个分片的首部长度与数据长度的总和。
                5）标识（identification）    占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。
                6）标志（flag）    占3位，但目前只有两位有意义。
                    ·标志字段中的最低位记为MF（MoreFragment）。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。
                    1标志字段中间的一位记为DF（Don'tFragment），意思是“不能分片”。只有当DF=0时才允许分片。
                7）片偏移   占13位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以8个字节位偏移单位。这就是说，每个分片的长度一定是8字节（64位）的整数倍。
                下面举一个例子。
                【例4-1】一数据报的总长度为3820字节，其数据部分为3800字节长（使用固定首部），需要分片为长度不超过1420字节的数据报片。因固定首部长度为20字节，因此每个数据报片的数据部分长度不能超过1400字节。于是分为3个数据报片，其数据部分的长度分别为1400，1400和1000字节。原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。
                本例中的数据报首部与分片有关的字段中的数值，其中标识字段的值是任意给定的（12345）。具有相同的数据报片在目的站就可无误地重装成原来的数据报。
                现在假定数据报片2经过某个网络时还需要再进行分片，即划分为数据报片2-1（携带数据800字节）和数据报片2-2（携带数据600字节）。那么这两个数据报片的总长度、标识、MF、DF和片偏移分别为：820，12345，1，0，175；620，12345，1，0，275。
                8）生存时间    占8位，生存时间字段常用的英文缩写是TTL（TimeToLive），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子（例如从路由器R1转发到R2，再转发到R3，然后又转发到R1），因而白白消耗网路资源。最初的设计是以秒作为TTL值的单位。每经过一个路由器时，就把TTL减去数据报在路由器所消耗的一段时间。若数据报在路由器消耗的时间小于1秒，就把TTL值减1。当TTL值减为零时，就丢弃这个数据报。
                然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于1秒钟，后来就把TTL字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把TTL值减1.若TTL值减小到零，就丢弃这个数据报，不再转发。因此现在TTL的单位不再是秒，而是跳数。TTL的意义是指明数据报在因特网中至多可经过多少个路由器。显然，数据报能在因特网中经过的路由器的最大数值是255.若把TTL的初始值设置为1，就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器，在被转发之前TTL值就减小到零，因而就会被这个路由器丢弃。
                9）协议    占8位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个处理过程。
                    常用的一些 协议和相应的协议字段值如下：
                    |协议名    |ICMP|IGMP|TCP|EGP|IGP|UDP|IPv6|OSPF|
                    ------------------------------------------------
                    |协议字段值|1   |2   |6   |8  |9  |17 |41  |89  |
                10）首部检验和    占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。为了进一步减小计算检验和的工作量，IP首部的检验和不采用复杂的CRC检验码而采用下面的简单计算方法：在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置零。用反码算术运算把所有的16位字段相加后，将得到的和的反码写入检验和字段。接收方接到数据报后，将首部的所有16位字段再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。
                11）源地址    占32位
                12）目的地址   占32位。
            2.IP数据报首部的可变部分
                IP首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从1个字节到40个字节不等，取决于所选择的项目。某些选项项目只需要1个字节，它只包括1个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全0的填充字段补齐成为4字节的整数倍。
                增加首部的可变部分是为了增加IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的IP版本IPv6就把IP数据报的首部长度做成固定的。因此这里不再继续讨论这些选项的细节。
        4.2.6IP层转发分组的流程
            下面我们先用一个简单例子来说明路由器是怎样转发分组的。一个路由表的简单的例子。有四个A类网络通过三个路由器连接在一起。每一个网络上都可能有成千上万个主机。可以想象，若按目的主机号来制作路由表，则所得出的路由表就会过于庞大（如果每一个网络由1万台主机，四个网络就有4万台主机，因而每一个路由表就有4万个项目，也就是4万行。每一行对应一个主机）。但若按主机所在的网络地址来制作路由表，那么每一个路由器中的路由表就只包含4个项目（即只有4行，每一行对应于一个网络）。以路由器R2的路由表为例。由于R2同时连接在网络2和网络3上，因此只要目的站在这两个网络上，都可通过接口0或1由路由器R2直接交付（当然还要利用地址解析协议ARP才能找到这些主机相对应的硬件地址）。若目的主机在网络1中，则下一跳路由器应为R1，其IP地址为20.0.0.7。路由器R2和R1由于同时连接在网络2上，因此从路由器R2把分组转发到路由器R1是很容易的。同理，若目的主机在网络4中，则路由器R2应把分组转发给IP地址为30.0.0.1的路由器R3.
            可以把整个网络拓扑简化。简化后，网络变成了一条链路，但每一个路由器旁边都注明其IP地址。使用这样的简化，可以使我们不用关心某个网络内部的具体拓扑以及连接在该网络上有多少台计算机，因为这些对于研究分组转发问题并没有什么关系。这样的简化强调了在互联网上转发分组时，是从一个路由器转发到下一个路由器。
            总之，在路由表中，对每一条路由最重要的是一下两个信息：（目的网络地址，下一跳地址）
            于是，我们就根据目的网络地址来确定下一跳路由器，这样做的结果是：
                1）IP数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的简介交付）。
                2）只有到达最后一个路由器时，才试图向目的主机进行直接交付。
            虽然因特网所有的分组转发都是基于目的主机所在的网络，但在大多数情况下都允许有这样的特例，即对特定的目的主机指明一个路由。这种路由叫做特定主机路由。采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。在对网络的连接或路由表进行排错时，指明到某一个主机的特殊路由就十分有用。
            路由器还可采用默认路由（default route）以减少路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。实际上，默认路由在主机发送IP数据报时往往更能显示出它的好处。我们在前面的4.2.1节已经讲过，主机在发送每一个IP数据报时都要查找自己的路由表。如果一个主机连接在一个小网络上，而这个网络只用一个路由器和因特网连接，那么在这种情况下使用默认路由是非常合适的。例如，在4-17的互联网中，连接在网络N1上的任何一个主机中的路由表只需要三个项目即可。第一个项目就是到本网络主机的路由，其目的网络就是本网络N1，因而不需要路由器转发，而是直接交付。第二个项目是到网络N2的路由，对应的下一跳路由器是R2.第三个项目就是默认路由。只要目的网络不是N1和N2，就一律选择默认路由，把数据报先间接交付到路由器R1，让R1再转发给下一个路由器，一直转发到目的网络上的路由器，最后进行直接交付。在实际上的路由器中，路由表中所示的“直接”和“默认”的几个字符并没有出现在路由表中，而是被记为0.0.0.0。
            这里我们应当强调指出，在IP数据报的首部中没有地方可以用来指明“下一跳路由器的IP地址”。在IP数据报的首部写上的IP地址是源IP地址和目的地址，而没有中间经过的路由器的IP地址。既然IP数据报中没有下一跳的IP地址，那么待转发的数据报又怎样能够找到下一跳路由器呢？
            当路由器收到一个待转发的数据报，在从路由表得出下一跳的IP地址后，不是把这个地址填入IP数据报，而是送交给下层的网络接口软件。网络接口软件负责把下一跳路由器的IP地址转换成硬件地址（使用ARP），并将此硬件地址放在链路层的MAC帧的首部，然后根据这个硬件地址找到下一跳路由器。由此可见，当发送一连串的数据报时，上述的这种查找路由表、计算硬件地址、写入MAC帧的首部等过程，将不断地重复进行、造成了一定的开销。
            那么，能不能在路由表中不实用IP地址而直接使用硬件地址呢？不行。我们一定要弄清楚，使用抽象的IP地址，本来就是为了隐藏各种底层网络的复杂性而便于分析和研究问题，这样就不可避免地要付出些代价，例如在选择路由时多了一些开销。但反过来，如果在路由表中直接使用硬件地址，那就会带来更多的麻烦。
            根据以上所述，可归纳出分组转发算法如下：
                1）从数据报的首部提取的主机的IP地址D，得出目的网络地址为N。
                2）若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付给目的主机（这里包括把目的主机地址D转换为具体的硬件地址，把数据报封装为 MAC帧，再发送此帧）；否则就是间接交付，执行3。
                3）若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行4。
                4）若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则；执行5。
                5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行6。
                6）报告转发分组出错。
            上面所讨论的是IP层怎样根据路由表的内容进行分组转发，而没有涉及到路由表一开始是如何建立的以及路由表中的内容应如何更新。但是在进一步讨论路由选择之前，我们还要先介绍分子网和构造超网这两个非常重要的概念。
4.3划分子网和构造超网
    4.3.1划分子网
        1.从两级IP地址到三级IP地址
        在今天看来，在ARPANET的早起，IP地址的设计确实不够合理。例如：
        第一，IP地址空间的利用率有时很低。
        每一个A类地址网络可连接的主机数超过1000万，而每一个N类地址网络可连接的主机数也超过6万。然而有些网络对连接在网络上的计算机数目有限制，根本达不到这样大的数值。例如10BASE-T以太网规定其最大节点数只有1024个。这样的以太网若使用一个B类地址就浪费6万多个IP地址，地址空间的利用率还不到2%，而其他单位的主机无法使用这些被浪费的地址。有的单位申请到了一个B类地址网络，但所连接的主机数并不多，可是又不愿意申请一个足够使用的C类地址，理由是考虑到今后可能的发展。IP地址的浪费，还会使IP地址空间的资源过早地被用完。
        第二，给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。
        每一个路由器都应当能够从路由表查出应怎样到达其他网络的下一跳路由器。因此，互联网中的网络数越多，路由器的路由表的项目数也就越多。这样，即使我们拥有足够多的IP地址资源可以给每一个物理网络分配一个网络号，也会导致路由器中的路由表中的项目数过多。这不仅增加了路由器的成本（需要更多的存储空间），而且使查找路由时耗费更多的时间，同时也使路由器之间定期交换的路由信息急剧增加，因而使路由器和整个因特网的性能都下降了。
        第三，两级IP地址不够灵活。
        有时情况紧急，一个单位需要在新的地点马上开通一个新的网络。但是在申请到一个新的IP地址之前，新增加的网络是不可能连接到因特网上工作的。我们希望有一种方法，使一个单位能随时灵活地增加本单位的网络，而不必事先到因特网管理机构去申请新的网络号。原来的两级IP地址无法做到这一点。
        为解决上述问题，从1985年起IP地址中又增加了一个“子网号字段”，使两级IP地址变成为三级IP地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法叫做划分子网（subnetting），或子网寻址或子网路由选择、划分子网已成为因特网的正式标准协议。
        划分子网的基本思路如下：
        1）一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网（subnet）。划分子网纯属一个单位内部的事情。本单位以外的网络看不见这个网络是由多少个子网组成，因为这个单位对外仍然变现为一个网络。
        2）划分子网的方式时从网络的主机号借用若干位作为子网号subnet-id，当然主机号也就相应减少了同样的位数。于是两级IP地址在本单位内部就变为三级IP地址：网络号、子网号和主机号。也可以用一下记法来表示：IP地址::={<网络号>,<子网号>,<主机号>}
        3）凡是从其他网络发送给本单位某个主机的IP数据报，仍然是根据IP数据报的目的网络好找到连接在本单位网络上的路由器。但此路由器在收到IP数据报后，再按目的网络好和子网号找到目的子网，把IP数据报交付给目的主机。
        下面用例子说明划分子网的概念某单位拥有一个B类IP地址，网络地址是145.13.0.0（网络号是145.13）。凡目的地址为145.13.x.x的数据报都被送到这个网络上的路由器R1.
        把网络划分为三个字网。这里假定子网号占用8位，因此在增加了子网号后，主机号就只有8位。所划分的三个字网分别是145.13.3.0，145.13.7.0和145.13.21.0.在划分子网后，整个网络对外部仍表现为一个网络，其网络地址仍为145.13.0.0。但网络145.13.0.0上的路由器R1在收到外来的数据报后，再根据数据报的目的地址把它转发到相应的子网。
        总之，当没有划分子网时，IP地址是两级结构。划分子网后IP地址变成了三级结构。划分子网只是把IP地址的主机号host-id这部分进行再划分，而不改变IP原来的网络号net-id。
        2.子网掩码
        现在剩下的问题就是：假定有一个数据报（其目的地址是145.13.3.10）已经到达了路由器R1.那么这个路由器如何把它转发到子网145.13.3.0呢？
        我们知道，从IP数据报的首部并不知道源主机或目的主机所连接的网络是否进行了子网的划分。这是因为32位的IP地址本身以及数据报的首部都没有包含任何有关子网划分的信息。因此必须另外想办法，这就是使用子网掩码（subnet mask）。
        IP地址为145.13.3.10的主机本来的两级IP地址结构。同一主机到的三级IP地址的结构，也就是说，现在从原来16位的主机号中拿出8位作为子网号subnet-id，而主机号减少到8位。请注意，现在子网号为3的网络的网络地址是145.13.3.0（既不是原来的网络地址，也不是子网号3）。为了使路由器R1能够很方便地从数据报中的目的IP地址中提取所要找的子网的网络地址，路由器R1就要使用子网掩码。子网掩码，它也是32位，由一串1和跟随的一串0组成。子网掩码中的1对用于IP地址中原来的net-id加上subnet-id，而子网掩码中的0对应于现在的host-id。虽然RFC文档中没有规定子网掩码中的1必须是连续的，但却极力推荐子网掩码中选用连续的1，以免出现可能发生的差错。
        R1把子网掩码和收到的数据报的目的IP地址145.13.3.10逐位相“与”（AND）（计算机进行这种逻辑AND运算是很容易的），得出了所要找的子网的网络地址145.13.3.0。
        使用子网掩码的好处是：不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位的“与”运算（AND），就立即得出网络地址来。这样在路由器处理到来的分组时就可采用同样的算法。
        这里还要弄清一个问题，这就是：在不划分子网时，既然没有子网，为什么还要使用子网掩码？这就是为了更便于查找路右边。现在因特网的标准规定：所有的网络都必须使用子网掩码，同时在路由器的的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码。默认子网掩码中1的位置和IP地址中的网络好字段net-id正好相对应。因此，若用默认子网掩码和某个不划分子网的IP地址逐位相“与”（AND），就应当能够得出该IP地址的网络地址来。这样做可以不用查找改地址的类别位就能知道这是哪一类的IP地址。显然，
            A类地址的默认子网掩码是255.0.0.0，或0xFF000000。
            B类地址的默认子网掩码是255.255.0.0，或0xFFFF0000。
            C类地址的默认子网掩码是255.255.255.0，或0xFFFFFF00。
            这三类IP地址的网络地址和相应的默认子网掩码。
        子网掩码是一个网络或一个子网的重要属性。在RFC950成为因特网的正式标准后，路由器在和相邻路由器交换路由器路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。
        我们以一个B类地址为例，说明可以有多少种子网划分的方法。在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的。
            ----------------------------------------------------------------
            |        |网络地址-默认子网掩码|net-id-host-id为全0               |
            |A类地址  |255.0.0.0          |11111111-000000000000000000000000|
            |B类地址  |255.255.0.0        |1111111111111111-0000000000000000|
            |C类地址  |255.255.255.0      |111111111111111111111111-00000000|
            ----------------------------------------------------------------
        ==========================================================================
            B类地址的子网划分选择（使用固定长度子网）
            ---------------------------------------------------
            |子网号的位数|子网掩码        |子网数|每个子网的主机数|
            |2          |255.255.292.0  |2     |16382         |
            |3          |255.255.224.0  |6     |8190          |
            |4          |255.255.240.0  |14    |4094          |
            |5          |255.255.248.0  |30    |2046          |
            |6          |255.255.252.0  |62    |1022          |
            |7          |255.255.254.0  |126   |510           |
            |8          |255.255.255.0  |254   |254           |
            |9          |255.255.255.128|510   |126           |
            |10         |255.255.255.192|1022  |62            |
            |11         |255.255.255.224|2046  |30            |
            |12         |255.255.255.240|4096  |14            |
            |13         |255.255.255.248|8190  |6             |
            |14         |255.255.255.252|16382 |2             |
            ---------------------------------------------------
        在表中，自王淑是根据子网号subnet-id计算出来的。若subnet-id有n位，则共有2^n种可能的排列。除去全0和全1这两种情况，就得出表中的子网数。
        表中的“子网号的位数”中没有0，1，15和16这四种情况，因为这没有意义。
        请读者注意，虽然根据已成为因特网标准协议的RFC950文档，子网号不能全1或全0，但随着无分类域间路由选择CIDR的广泛使用，现在全1和全0的子网号也可以使用了，但一定要谨慎使用，要弄清你的路由器所用的路由选择软件是否支持全0或全1的子网号这种较新的用法。
        我们可以看出，若使用较少位数的子网号，则每一个子网上可连接的主机数就较多。反之，若使用较多位数的子网号，则子网的数目较多但每个字网上课连接的主机数就较少。因此我们可根据网络的具体情况（一共需要划分多少个子网，每个字网最多有多少个主机）来选择合适的子网掩码。
        通过简单的计算，读者不难得到这样的结论：划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。例如，本来一个B类地址最多可连接65534台主机，但表中任意一行的最后两项的乘积一定小于65534。
        对A类和C类地址的子网划分也可得出类似的表格，读者可自行算出。
        例4-2已知IP地址是141.14.72.24，子网掩码是255.255.192.0。试求网络地址。
            子网掩码是11111111 11111111 11000000 00000000。请注意，掩码的钱两个字节都是全1，因此网络地址的前两个字节位141.14。子网掩码的第四字节是全0，因此网络地址的第四字节是0。可见本题仅需对地址中的第三字节进行计算。我们只要把IP地址和子网掩码的第三字节用二进制表示，就可以很容易地得出网络地址。
            a.点分十进制表示的IP地址        141.      14.      72.      24
            b.IP地址的第3字节是二进制       141.      14.01001000.      24
            c.子网掩码是255.255.192.0 11111111.11111111.11000000.00000000
            d.IP地址与子网掩码逐位相与      141.      14.01000000.       0
            e.网络地址（点分十进制表示）    141.      14.       64.      0
        例4-3在上例中，若子网掩码改为255.255.224.0。试求网络地址，并讨论所得结果。
            用同样方法，可以得出网络地址是141.14.64.0，和例4-2的结果完全一样。
            a.点分十进制表示的IP地址        141.      14.      72.      24
            b.IP地址的第3字节是二进制       141.      14.01001000.      24
            c.子网掩码是255.255.192.0 11111111.11111111.11100000.00000000
            d.IP地址与子网掩码逐位相与      141.      14.01000000.       0
            e.网络地址（点分十进制表示）     141.      14.       64.      0
            这个例子说明，同样的IP地址和不通的子网掩码可以得出相同的网络地址。但是，不通的掩码的效果是不同的。在例4-2中，subnet-id是2位，host-id是14位。在例4-3中，subnet-id是3位，host-id是13位。因此这两个例子中可划分的子网数和每一个子网中国的最大主机数都是不一样的。
        下面进一步讨论使用了子网掩码后应怎样查找路由表。
    4.3.2使用子网时分组的转发
        在划分子网的情况下，分组转发的算法必须做相应的改动。
        我们应当注意到，使用子网划分后，路由表必须包含以下三项内容：目的网络地址、子网掩码和下一跳地址。
        在划分子网的情况下，路由器转发分组的算法如下：
            1）从收到的数据报的首部提取目的IP地址D。
            2）先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和D逐位相“与”（AND操作），看结构是否和相应的网络地址匹配。若匹配，则把分组进行直接交付（当然还需要把D转换成物理地址，把数据报疯转成帧发送出去），转发任务结束。否则就是间接交付，执行3。
            3）若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行4。
            4）对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和D逐位相“与”（AND操作），其结果为N。若N与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行5。
            5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行6。
            6）报告转发分组出错。
        例4-4已知互联网，以及路由器R1中的路由表。现在主机H1向H2发送分组。试讨论收到H1向H2发送的分组后查找路由表的过程。
            -----H1：128.30.33.13-------------------------------子网1：网络地址128.30.22.0子网掩码255.255.255.128
                                     |（128.30.33.1）
                                     R1
                                     |（128.30.33.130）
            -------------------------------H2：128.30.33.138----子网2：网络地址128.30.33.128子网掩码255.255.255.128
                |（128.30.33.129）
                R2
                |（128.30.36.2）
            --------H3：128.30.36.12-----------------------------子网3：网路地址128.30.36.0子网掩码255.255.255.0

            =========================================================================
            R1的路由表（未给出默认路由器）
            |目的网络地址  |子网掩码        |下一跳|
            |128.30.33.0  |255.255.255.128|接口0 |
            |128.30.33.128|255.255.255.128|接口1 |
            128.30.36.0   |255.255.255.0  |R2    |
            ===============================================
            主机H1向H2发送的分组目的地址是H2的IP地址128.30.33.138。主机H1首先要进行的操作是把本子网的“子网掩码255.255.255.128”与H2的“IP地址128.30.33.138”逐位相“与”，得出128.30.33.128，它不等于H1的网络地址（128.30.33.0）。这说明H2与H1不在同一个子网上。因此H1不能把分组直接交付给H2.而必须交给子网上的默认路由器R1，由R1来转发。
            路由器R1在收到一个分组后，先找到路由表中的第一行，看看这一行的网络地址和收到的分组的网络是否匹配。因为并不知道收到的分组的网络地址，因此只能试试看。这就是用这一行（子网1）的“子网掩码255.255.255.128”和收到的分组的“目的地址128.30.33.138”逐位相“与”，得出128.39.33.128.然后和这一行给出的目的地址进行比较。但现在比较的结果是不一致（即不匹配）。
            用同样方法继续往下找第二行。用第二行的“子网255.255.255.128”和该分组的“目的地址128.30.33.128”逐位相“与”，结果也是128.30.33.128。但这个结果和第二行目的的网络相匹配，说明这个网络（子网2）就是收到分作所要寻找的出口网络。于是我不需要再找下一个路由器进行间接交付了。R1把分组从接口1直接交付给主机H2 （它们都在一个子网上）。
    4.3.3无分类编织CIDR（构造超网）
        1.网络前缀
            划分子网在一定程度上缓解了因特网在发展中遇到的困难。然而在1992年因特网仍然面临三个必须尽早解决的问题，这就是：
                1）B类地址在1992年已分配了近一半，眼看很快就将全部分配完毕！
                2）因特网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。
                3）整个IPv4的地址空间最终将全部耗尽。
            当时预计前两个问题将在1994年变得非常严重。因此IETF很快地就研究出采用无分类编址的方法来解决前两个问题。IETF认为上面的第三个问题属于更加长远的问题，因此专门成立IPv6工作组负责研究解决新版本IP协议的问题。
            其实早在1987年，RFC1009就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。使用变长子网掩码VLSM（Variable Length Subnet Mask）可进一步提高IP地址资源的利用率。在VLSM的基础上又进一步研究出无分类编址方法，它的正式名字是无分类域间路由选择CIDR（Classless Inter-Domain Rounting，CIDR的读音是“sider”）。在1993年形成了CIDR的RFC文档：RFC1517~1519和1520。现在CIDR已经成为因特网建议标准协议。
            CIDR最主要的特点有两个：
                1）CIDR消除了传统的A类、B类和C类地址以及划分子网的概念，因而可以更加有效地分配IPv4的地址空间，并且可以在新的IPv6使用之前容许因特网的规模继续增长。CIDR把32位的IP地址划分为两个部分。前面的部分是“网络前缀”（network-prefix）（或简称为“前缀”），用来指明网络，后面的部分则用来指明主机。因此CIDR使IP地址从三级编址（使用子网掩码）又回到了两级编址，但这已是无分类的两级编址。他的记法是：IP地址::={<网络前缀>,<主机号>}，CIDR还使用“斜线记法”（slash notation），或称为CIDR记法，即在IP地址后面加上斜线“/”，然后写上网路前缀所占的位数。
                2）CIDR把网络前缀都相同的连续的IP地址组成一个“CIDR地址块”。我们只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。例如，已知IP地址128.14.35.7/20是某CIDR地址块中的一个地址，现在把它写成二进制表示，其中的前20位是网络前缀，而前缀后面的12位是主机号：128.14.35.7/20=10000000 00001110 0010|0011 00000111
                        这个地址所在的地址块中的最小地址和最大地址可以很方便地得出：
                            最小地址    128.14.32.0    10000000 00001110 0010|0000 00000000
                            最大地址    128.14.47.255  10000000 00001110 0010|1111 11111111
                    当然，这两个主机号是全0和全1的地址一般不使用。通常只使用在这两个地址之间的地址。不难看出，这个地址块共有2^12个地址。我们可以用地址块中的最小地址和网络前缀的位数指明这个地址块。例如，上面的地址块可记为128.14.32.0/20。在不需要指出地址块的起始地址时，也可把这样的地址块简称为“/20地址块”。
                    为了更方便地进行路由选择，CIDR使用32位的地址掩码（address mask）。地址掩码是一串1和一串0组成，而1的个数就是网络前缀的长度。虽然CIDR不使用的子网了，但由于目前仍有一些网络还使用子网划分和子网掩码，因此CIDR使用的地址掩码也可继续称为子网掩码。例如，/20地址块的地址掩码是：11111111 11111111 11110000 00000000（20个连续的1）。斜线记法中，斜线后面的数字就是地址掩码中1的个数。
                    请读者注意，“CIDR不使用子网”时指CIDR并没有在32位地址中指明若干位作为子网字段（subnet-id）。但分配到一个CIDR地址块的组织，仍然可以在本组织内根据需要划分出一些子网。这些子网也都只有一个网络前缀和主机好字段，但子网的网络前缀比整个组织的网络前缀要长些。例如某组织分配到地址块/20，就可以再划分为8个子网（即需要从主机号中借用3位来划分子网）。这时每一个子网的网络前缀就变成23位（原来的20位加上从主机号借来的3位），比该组织的网络前缀长3位。
                    斜线记法还有一个好处就是它除了表示一个IP地址外，还提供了其他一些重要信息。
                    例如，地址192.199.170.82/27不仅表示IP地址是192.188.170.82，而且还表示这个地址块的网络的前缀有27位，地址块包含32个IP地址。通过简单的计算还可得出，这个地址块的最小地址是192.199.170.64，最大地址是192.199.170.95.具体的计算方法是这样的。找出地址掩码中1和0的交界处发生在地址中的哪一个字节。现在是第四个字节。因此只要把这一个字节用二进制表示，写成01010010，取其前3位（这3位加上前3个字节的24位等于前缀的27位），再把后面的5位都写成0，即010|00000，等于十进制的64.这就找出了地址块的最小地址。再把地址的第四字节的最后5位都置1，即010|11111，等于十进制的95，这就找出了地址块中的最大地址。
                    由于一个CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络。这种地址的聚合常称为路由聚合（route aggregation），它使得路由表中的一个项目可以表示原来传统分类地址的很多个（例如上千个）路由。路由聚合也称为构成超网（supernetting）。如果没有采用CIDR，则在1994和1995年，因特网的一个路由表就会超过7万个项目，而使用了CIDR后，在1996年一个路由表的项目数才只有3万多个。路由聚合有利于减少路由器之间选择信息的交换，从而提高了整个因特网的性能。
                    CIDR记法有多种形式，例如，地址块10.0.0.0/10可简写为10/10，也就是把点分十进制中低位连续的0省略。另一种简化表示方法是在网络前缀的后面加一个星号*，如：0000101000*  ，意思是：在星号*之前是网络前缀，而星号*表示IP地址中的主机号，可以是任意值。前缀位数不是8的整数倍时，需要进行简单的计算才能得到一些地址信息。
                    常用的CIDR地址块。表中的K表示2^10即1024.网络前缀小于13或大于27都较少使用。在“包含的地址数”中没有把全1和全0的主机号除外。
                        |CIDR前缀长度|点分十进制      |包含的地址数|相当于包含分类的网络数|
                        |/13        |255.248.0.0    |512K       |8个B类或2048个C类    |
                        |/14        |255.252.0.0    |256K       |4个B类或1024个C类    |
                        |/15        |255.254.0.0    |128K       |2个B类或512个C类     |
                        |/16        |255.255.0.0    |64K        |1个B类或256个C类     |
                        |/17        |255.255.128.0  |32K        |128个C类             |
                        |/18        |255.255.192.0  |16K        |64个C类              |
                        |/19        |255.255.224.0  |8K         |32个C类              |
                        |/20        |255.255.240.0  |4K         |16个C类              |
                        |/21        |255.255.248.0  |2K         |8个C类               |
                        |/22        |255.255.252.0  |1K         |4个C类               |
                        |/23        |255.255.254.0  |512        |2个C类               |
                        |/24        |255.255.255.0  |256        |1个C类               |
                        |/25        |255.255.255.128|128        |1/2个C类             |
                        |/26        |255.255.255.192|64         |1/4个C类             |
                        |/27        |255.255.255.224|32         |1/8个C类             |
                    从表可看出，每一个CIDR地址块中的地址数一定是2的整数次幂。除最后几行外，CIDR地址块都包含了多个C类地址（是一个C类地址的2^n倍，n是整数），这就是“构成超网”这一名词的来源。
                    使用CIDR的一个好处就是可以更加有效地分配IPv4的地址空间，可根据客户的需要分配适当大小的CIDR地址块。然而在分类地址的环境中，向一个组织分配IP地址，就只能以/8,/16或/24为单位来分配。这就很不灵活。
                    CIDR地址块分配的例子。假定某ISP已拥有地址块206.0.64.0/18（相当于有64个C类网络）。现在某大学需要800个IP地址。ISP可以给该大学分配一个地址块206.0.68.0/22，它包括1024（即2^10）个IP地址，相当于4个连续的C类/24地址块，占该ISP拥有的地址空间的1/16。这个大学然后可自由地对本校的各系分配地址块，而各系还可再划分本系的地址块。CIDR的地址块分配有时不易看清，这是因为网络前缀和主机号的界限不是恰好出现在整数字节处。只要写出地址的二进制表示（从表中可看出，实际上只需要将其中的一个关键字节转换为二进制的表示即可），弄清网络前缀的位数，就不会把地址块的范围弄错。
                    地址聚合的概念。这个ISP共拥有64个C类网络。如果不采用CIDR技术，则在与该ISP的路由器交换路由信息的每一个路由器的路由表中，就需要有64个项目。但采用地址聚合后，就只需要用路由聚合的一个项目206.0.64.0/18就能找到该ISP。同理，这个大学共有4个系。在ISP内的路由器的路由表中，也是需使用206.0.68.0/22这一个项目。
                    从表格中的二进制地址可看出，把四个系的路由聚合为大学的一个路由（即构成超网），是将网络前缀缩短。网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀边长。
                            |单位|地址块          |二进制表示                   |地址数|
                            |ISP|206.0.64.0/18   |11001110.00000000.01*       |16384 |
                            |大学|206.0.68.0/22  |1101110.00000000.010001*     |1024 |
                            |一系|206.0.68.0/23  |11001110.00000000.0100010*   |512  |
                            |二系|206.0.70.0/24  |11001110.00000000.01000110.* |256  |
                            |三系|206.0.71.0/25  |11001110.00000000.01000111.0*|128  |
                            |四系|206.0.71.128/25|11001110.00000000.01000111.1*|128  |
        2.最长前缀匹配
            在使用CIDR时，由于采用了网络前缀这种记法，IP地址由网络前缀和主机号这两个部分组成，因此在路由表中的项目也有相应的改变。这是，每个项目由“网络前缀”和“下一跳地址”组成。但是在查找路由表时可能会得到不止一个匹配结果。这样就带来一个问题：我们应当从这些匹配结果中选择哪一条路由呢？
            正确的答案是：应当从匹配结果中选择具有最长网络前缀的路由。这叫作最长前缀匹配（longest-prefix matching），这是因为网络前缀越长，其地址块就越小，因而路由就越具体（more specific）。最长前缀匹配又称为最长匹配或最佳匹配。为了说明最长前缀匹配的概念，我们仍以前面的例子来讨论。
            假定大学下属的四系希望ISP把转发给四系的数据报直接发到四系而不要经过大学的路由器，但又不愿意改变自己使用的IP地址块。因此，在ISP的路由器的路由表中，至少要有以下两个项目，即206.0.68.0/22（大学）和206.0.71.128/25（四系）。现在假定ISP收到一个数据报，其目的IP地址为D=206.0.71.130。把D分别和路由表中这两个项目的掩码逐位相“与”（AND操作）。将所得的逐位AND操作的结果按顺序写在下面。
                D和11111111 11111111 111111|00 00000000逐位相“与”=206.0.68.0/22    匹配
                D和11111111 11111111 11111111 1|0000000逐位相“与”=206.0.71.128/25    匹配
            不难看出，现在同一个IP地址D可以在路由表中找到两个目的网络（大学和四系）和该地址相匹配。根据最长前缀匹配的原理，应当选择后者，把收到的数据报转发到后一个目的网络（四系），即选择两个匹配的地址中更具体的一个。
            从以上的谈论可以看出，如果IP地址的分配一开始就采用CIDR，那么我们可以按网络所在的地理位置来分配地址块，这样就可大大减少路由表中的路由项目。例如，可以将世界划分为四大地区，每一个地区分配一个CIDR地址块：
                地址块194/7(194.0.0.0至195.255.255.255)分配给欧洲；
                地址块198/7(198.0.0.0至199.255.255.255)分配给北美洲；
                地址块200/7(200.0.0.0至201.255.255.255)分配给中美洲和南美洲；
                地址块202/7(202.0.0.0至203.255.255.255)分配给亚洲和太平洋地区。
            上面的每一个地址块包含有约3200万个地址。这种分配地址的方法就使得IP地址与地理位置相关联。它的好处是可以大大压缩路由表中的项目数。例如，凡是从中国发往北美的数据报（不管它是地址块198/7中的哪一个地址）都先送交位于美国的一个路由器，因此在路由表中使用一个项目就行了。
            但是，在使用CIDR之前，因特网的地址管理机构没有按地理位置来分配IP地址。现在要把已分配出的IP地址收回再重新分配是十分困难的事，因为这牵涉到很多正在工作的主机必须改变其IP地址。尽管这样，CIDR的使用已经推迟了IP地址将要耗尽的日期。
        3.使用二叉线索查找路由表
            使用CIDR后，由于要寻找最长前缀匹配，使路由表的查找过程变得更加复杂了。当路由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。例如，连接路由器的线路的速率为10Gb/s，而分组的平均长度为2000bit，那么路由器就应当平均每秒钟能够处理500万个分组（常记为5Mpps）。或者说，路由器处理一个分组的平均时间只有200ns（1ns=10^-9秒）。因此，查找每一个路由所需的时间应当是非常短的。可见在路由表中必须使用很好的数据结构和使用先进的快速查找算法，这一直是人们积极研究的热门课题。
            对无分类编址的路由表的最简单的查找算法就是对所有可能的前缀进行循环查找。例如，给定一个目的地址D。对每一个可能的网络前缀长度M，路由器从D中提取前M个位成一个网络前缀，然后查找路由表中的年网络前缀。所找到的最长匹配就对应于要查找的路由。
            这种最简单的算法的明显缺点就是查找的次数太多。最坏的情况是路由表中没有这个路由。在这种情况下，算法仍要进行32次（具有32位的网络前缀是一个特定主机路由）。就是要找到一个传统的B类地址（即/16），也要查找16次。对于经常使用的默认路由，这种算法都要经历31次的不必要的查找。
            为了进行更加有效的查找，通常是把无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是二叉线索（binary trie），它是一种特殊结构的树。IP地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。
            一个例子来说明二叉线索的结构。5个IP地址。为了简化二叉线索的结构，可以先找出对用于每一个IP地址的唯一前缀（unique prefix）。所谓唯一前缀就是在表中所有的IP地址中，该前缀是唯一的。这样就可以用这些唯一前缀来构造二叉线索。在进行查找时，只要能够和唯一前缀相匹配就行了。
                5个前缀构成的二叉线索：
                32位的IP地址                        |唯一前缀
                01000110 00000000 00000000 00000000|0100
                01010110 00000000 00000000 00000000|0101
                01100001 00000000 00000000 00000000|011
                10110000 00000010 00000000 00000000|10110
                10111011 00001010 00000000 00000000|10111
            从二叉线索的根节点自顶向下的深度最多有32层，每一层对应于IP地址中的一位。一个IP地址存入二叉线索的规则很简单。先检查IP地址左边的第一位，如为0，则第一层的结点就在根节点的左下方；如为1，则在右下方。然后再检查地址的第二位，构造出第二层的节点。以此类推，直到唯一前缀的最后一位。由于唯一前缀一般都小于32位，因此用唯一前缀构造的二叉线索的深度往往不到32层。图中较粗的折线就是前缀0101在这个二叉线索中的路径。二叉线索中的小圆圈是中间节点，而在路径终点的小方框是叶节点（也叫做外部结点）。每个叶节点代表一个唯一前缀。节点之前的连线旁边的数字表示这条边在唯一前缀中对应的比特是0或1。
            假定有一个IP地址是10011011 01111010 00000000 00000000，需要查找该地址是否在此二叉线索中。我们从最左边查起。很容易发现，查到第三个字符（即前缀10后面的0）时，在二叉线索中就找不到匹配的，说明这个地址不在这个二叉线索中。
            以上只是给出了二叉线索这种数据结构的用法，而并没有说明“与唯一前缀匹配”和“与网络前缀匹配”的关系。显然，要将二叉线索用于路由表中，还必须使二叉线索中的每一个叶节点包含所对应的网络前缀的子网掩码。当搜索到一个叶节点时，就必须将寻找匹配的目的地址和该叶节点的子网掩码进行逐位“与”运算，看结果是否与对应的网络前缀相匹配。若匹配，就按下一跳的接口转发该分组。否则，就丢弃该分组。
            总之，二叉线索只是提供了一种可以快速在路由表中找到匹配的叶节点的机制。但这是否和网络前缀匹配，还要和子网掩码进行一次逻辑与的运算。
            为了提高二叉线索的查找速度，广泛使用了各种压缩技术。例如，在图中的最后两个地址，其最前面的4位都是1011.因此，只要一个地址的前4位是1011，就可以跳过前面4位（即压缩了4个层次）而直接从第5位开始比较。这样就可以减少查找的时间。当然，制作经过压缩的二叉线索需要更多的计算，但由于每一次查找路由表时都可以提高查找速度，因此这样做还是值得的。
4.4网际控制报文协议ICMP
    为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP（Internet Control Message Protocol）。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP是因特网的标准协议。但ICMP不是高层协议，而是IP层的协议。ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。ICMP报文格式：
        位                  0       8         16          31
        前4个字节是统一的格式|类型    |代码      |检验和      |
                           |（这4个字节取决于ICMP报文的类型）|
                           |ICMP的数据部分（长度取决于类型） |
                                   |ICMP报文|
                                       ↓
                              |首部|数据部分 |
                           ←------IP数据报----→
    4.4.1ICMP报文的种类
        ICMP报文的种类有两种，即ICMP差错报告报文和ICMP询问报文。
        ICMP报文的前4个字节是统一的格式，共有三个字段：即类型、代码和校验和。接着的4个字节内容与ICMP的类型有关。最后是数据字段，其长度取决于ICMP的类型。
            几种常用的ICMP报文类型：
            |ICMP报文种类|类型的值|ICMP报文的类型              |
            -------------------------------------------------
            |           |3       |终点不可达                  |
            |           |4       |源点抑制（Source quench）   |
            |差错报告报文|11      |时间超过                    |
            |           |12      |参数问题                    |
            |           |5       |改变路由（Redirect）        |
            --------------------------------------------------
            |询问报文   |8或0     |回送（Echo）请求或回答       |
            |          |13或14   |时间戳（Timestamp）请求或回答|
        现在已不再使用ICMP报文有“信息请求与回答报文”、“地址掩码请求与回答报文”和“路由器请求与通告报文”，这些报文就没有出现在表中。
        ICMP报文的代码字段是为了进一步区分某种类型中的几种不同的情况。检验和字段用来检验整个ICMP报文。我们应当还记得，IP数据报首部的检验和并不检验IP数据报的内容，因此不能保证经过传输的ICMP报文不产生差错。
        ICMP差错报告报文共有五种，即：
            1）终点不可达   当路由器或主机不能交付数据报时就向源点发送终点不可达报文。
            2）源点抑制    当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。
            3）时间超过    当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向远点发送时间超过报文。
            4）参数问题    当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。
            5）改变路由（重定向）   路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。
              下面对改变路由报文进行简短的解释。我们知道，在因特网的主机中也要有一个路由表。当主机要发送数据报时，首先是查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。在因特网中主机的数量远大于路由器的数量，出于效率的考虑，这些主机不喝连接在网络上的路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个默认路由器的IP地址。不管数据报要发送到那个目的地址，都一律先将数据报传送给网络上的这个默认路由器，而这个默认路由器知道到每一个目的网络的最佳路由（通过和其他路由器交换路由信息）。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由不应当经过默认路由器而是应当经过网络上的另一个路由器R时，就改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目：到某某目的地址应经过路由器R（而不是默认路由器）。
        所有的ICMP差错报告报文中的数据字段都具有同样的格式。把收到的需要进行差错报告的IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文的数据字段。再加上相应的ICMP差错报告报文的前8个字节，就构成了ICMP差错报告报文。提取收到的数据报的数据字段的前8个字节是为了得到运输层的端口号（对于TCP和UDP）以及运输层报文的发送序号（对于TCP）。这些信息对源点通知高层协议是有用的（端口的作用将在下一章的5.1.3节中介绍）。整个ICMP报文作为IP数据报的数据字段发送给源点。
            下面是不应发送ICMP差错报告报文的几种情况：
            ·对ICMP差错报告报文不再发送ICMP差错报告报文。
            ·对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。
            ·对具有多播地址的数据报都不发送ICMP差错报告报文。
            ·对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文。
            常用的ICMP询问报文有两种，即：
            1）回送请求和回答   ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。
            2）时间戳请求和回答    ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900奶奶1月1日起到当前时刻一共有多少秒。时间戳请求与回答可用来进行时钟同步和测量时间。
    4.4.2ICMP的应用举例
        ICMP的一个重要应用就是分组网间探测PING（Packet InterNet Groper），用来测试两个主机之间的连通性。PING使用了ICMP会送请求与回送回答报文。PING是应用层直接使用网络层ICMP的一个例子。他没有通过运输层的TCP或UDP。
        windows操作系统的用户可在接入因特网后转入MS DOS（点击“开始”，点击“运行”，再键入“cmd”）。看见屏幕上的提示符后，就键入“ping hostname”（这里的hostname是要测试连通性的主机名或它的IP地址），按回车键后可看到结果。
        从南京的一台PC机到新浪网的邮件服务器mail。sina。com。cn的连通性的测试结果。PC机一连发出四个ICMP回送请求报文。如果邮件服务器mail.sina.com.cn正常工作而且响应这个ICMP回送请求报文（有的主机为了防止恶意攻击就不理睬外界发送过来的这种报文），那么它就发回ICMP回送回答报文。由于往返的ICMP报文上都有时间戳，因此很容易得出往返时间。最后显示出的是统计结果：发送到哪个机器（IP地址），发送的、收到的和丢失的分组数（但不给出分组丢失的原因）。往返时间的最小值、最大值和平均值。从得到的结果可以看出，第三个测试分组丢失了。
        另一个非常有用的应用是traceroute（这是UNIX操作系统中的名字），它用来跟踪一个分组从源点到终点的路径。在windows操作系统中这个命令是tracert。下面简单介绍这个程序的工作原理。
        Traceroute从源主机向目的主机发送一连串的IP数据报，数据报中封装的是无法交付的UDP用户数据报。第一个数据报P1的生存时间TTL设置为1.当P1到达路径上的第一个路由器R1时，路由器R1先收下它，接着把TTL的值减1.由于TTL等于零了，R1就把P1丢弃了，并向源主机发送一个ICMP时间超过差错报告报文。
        源主机接着发送第二个数据报P2，并把TTL设置为2。P2先到达路由器R1，R1收下后把TTL减1再转发给路由器R2。R2收到P2时TTL为1，但减1后TTL变为零了。R2就丢弃P2，并向源主机发送一个ICMP时间超过差错报告报文。这样一直继续下去。当最后一个数据报刚刚到达目的主机时，数据报的TTL是1.主机不转发数据报，也不把TTL值减1.但因IP数据报中封装的是无法交付的运输层的UDP用户数据报，因此目的主机要向源主机发送ICMP终点不可达差错报告报文。
        这样，源主机达到了自己的目的，因为这些路由器和最后目的主机发来的ICMP报文正好给出了源主机想知道的路由信息----到达目的主机所经过的路由器的IP地址，以及到达其中的每一个路由器的往返时间。南京的一个PC机向新浪网的邮件服务器mail.sina.com.cn发出的tracert命令后所获得的结果。每一行有三个时间出现，是因为对应于每一个TTL值，源主机要发送三次同样的IP数据报。
            我们还应注意到，从原则上讲，IP数据报经过的路由器越多，所花费的时间也会越多。但，有时正好相反。这是因为因特网的拥塞程度随时都在变化，也很难预料到。因此，完全有这样的可能：经过更多的路由器反而花费更少的时间。
4.5因特网的路由选择协议
    本节将讨论几种常用的路由选择协议，也就是要讨论路由表中的路由是怎样得出的。
    4.5.1有关路由选择的几个基本概念
        1.理想的路由算法
        路由选择协议的核心就是路由算法，即需要何种算法来获得路由表中各项目。一个理想的路由算法应具有如下的一些特点：
            1）算法必须是正确的和完整的。这里，“正确”的含义是：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。
            2）算法在计算上应简单。路由选择的计算不应使网络通信量增加太多的额外开销。
            3）算法应能适应通信量和网络拓扑的变化。这就是说，要有自适应性。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些结点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自适应性为“稳健性”（robustness）。
            4）算法应具有稳定性。在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停地变化。
            5）算法应是公平的。路由选择算法应对所有用户（除对少数优先级高的用户）都是平等的。例如，若仅仅使某一对用户的端到端时延为最小，但却不考虑其他的广大用户，这就明显地不符合公平性的要求。
            6）算法应是最佳的。路由选择算法应当能够找出最好的路由，使得分组平均时延最小而网络的吞吐量最大。虽然我们希望得到“最佳”的算法，但这并不总是最重要的。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。
            一个实际的路由选择算法，应尽可能接近于理想的算法。在不同的应用条件下，对以上提出的六个方面也可由不同的侧重。
            应当指出，路由选择是个非常复杂的问题，因为它是网络中的所有结点共同协调工作的结果。其次，路由选择的环境往往是不断变化的，而这种变化有时无法事先知道，例如，网络中出了某些故障。此外，当网络发生拥塞时，就特别需要有能缓解这种拥塞的路由选择策略，但恰好在这种条件下，很难从网络中的各结点获得所需的路由选择信息。
        倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两大类，即静态路由选择策略与动态路由选择策略。静态路由选择也叫做非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由。动态路由选择也叫做自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。因此，动态路由选择适用于较复杂的大网络。
        2.分层次的路由选择协议
        因特网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。由于以下两个原因，因特网采用分层次的路由选择协议：
            1）因特网的规模非常大，现在就已经有几百万个路由器互连在一起。如果让所有的路由器知道所有的网络应该怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使因特网的通信链路饱和。
            2）许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到因特网上。
        为此，因特网将整个互联网划分为许多较小的自制系统（autonomous system），一般都记为AS。
        RFC4271对自制系统AS有下面这样的描述：
            自制系统AS的经典定义是在单一技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由选择协议用以确定分组在AS之间的路由。自从有了这个经典定义后，使用多种内部路由选择协议和多种度量的AS也是常用的。因此，现在对自制系统AS的定义是调下面的事实：尽管一个AS使用了多种内部路由选择协议和度量，但重要的是一个AS对其他AS表现出的是一个单一的和一致的路由选择。
        在目前的因特网中，一个大的ISP就是一个自制系统。这样，因特网就把路由选择协议划分为两大类，即：
            1）内部网关协议IGP（Interior Gateway Protocol）    即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如RIP和OSPF协议。
            2）外部网关协议EGP（External Gateway Protocol）    若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议EGP。目前使用最多的外部网关协议是BGP的版本4。
        自治系统之间的路由选择也叫做遇见路由选择（interdomain routing），而在自治系统内部的路由选择叫做域内路由选择（intradomain routing）。
        每一个自制系统自己决定在本自治系统内部运行哪一个内部路由选择协议（例如，可以是RIP，也可以是OSPF）。但每个自治系统都有一个或多个路由器（R1和R2）除运行本系统的内部路由选择协议外，还要运行自治系统间的路由选择协议。
        这里我们要指出两点：
            1）因特网的早起RFC文档中未使用“路由器”而是使用“网关”这一名词。但是在新的RFC文档中又使用了“路由器”这一名词，因此有的书把原来的IGP和EGP分别改为IRP（内部路由器协议）和ERP（外部路由器协议）。为了方便读者查阅RFC文档，本书仍使用RFC原先使用的名字IGP和EGP。
            2）RFC采用的名词IGP和EGP是协议类别的名称。但RFC在使用名词EGP时出现了一点混乱，因为最早的一个外部网关协议的协议名字正好也是EGP。后来发现该RFC提出的EGP有不少缺点，就设计了一种更好的外部网关协议，叫做边界网关协议BGP（Border Gateway Protocol），用来取代旧的RFC827外部网关协议EGP。实际上，旧协议EGP和新协议BGP都属于外部网关协议EGP这一类别。因此在遇到名词EGP时，应弄清它是指旧协议EGP还是指外部网关协议EGP这个类别。
            总之，使用分层次的路由选择方法，可将因特网的路由选择协议划分为：
            ·内部网关协议IGP：具体的协议有多种，如RIP和OSPF等。
            ·外部网关协议EGP：目前使用的协议就是BGP。
        对于比较大的自治系统，还可将所有的网络再进行一次划分。例如，可以构筑一个链路速率较高的主干网和许多速率较低的区域网。每个区域通过路由器连接到主干网。在一个区域内找不到目的站时，就通过路由器经过主干网到达另一个区域网，或者通过外部路由器到别的自治系统中去查找。下面对这两类协议分别进行介绍。
    4.5.2内部网关协议RIP
        1.工作原理
        路由信息协议RIP（Routing Information Protocol）是内部网关协议IGP中最先得到广泛使用的协议。RIP是一种分布式的基于距离向量的路由选择协议，是因特网的标准协议，其最大优点就是简单。
        RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（因此，这是一组距离，即“距离向量”）。RIP协议将“距离”定义如下：
        从一路由器到直接连接的网络的距离定义为1.从一路由器到直接连接的网络的距离定义为所经过的路由器数加1。“加1”是因为到达目的网络后就直接交付，而到直接连接的网络的距离已经定义为1.例如在前面讲过的，路由器R1到网1或网2的距离都是1（直接连接），而到网3的距离是2，到网4的距离是3。
        RIP协议的“距离”也称为“跳数”（hop count），因为每经过一个路由器，跳数就加1。RIP认为好的路由就是它通过的路由器的数目少，即“距离短”。RIP允许一条路径最多只能包含15个路由器。因此“距离”等于16时即相当于不可达。可见RIP只适用于小型互联网。
        需要注意的是，到直接连接的网络的距离也可定义为0（采用这种定义的理由是：路由器在和直接连接在该网络上的主机通信时，不需要经过另外的路由器。既然每经过一个路由器要将距离加1，那么不再经过路由器的距离就应当为零）。作者编写的其他版本的教材过去也曾使用过这种定义。但两种不同的定义对实现RIP协议并无影响，因为重要的是要找出最短距离，将所有的距离都加1或都减1，对选择最佳路由其实是一样的。
        RIP不能再两个网络之间同时使用多条路由。RIP选择一条具有最少路由器的路由（即最短路由），哪怕还存在另一条高速（低时延）但路由器较多的路由。
        本届讨论的RIP协议和下一节要讨论的OSPF协议，都是分布式路由选择协议。它们的共同特点就是每一个路由器都要不断地和其他一些路由器交换路由信息。我们一定要弄清一下三个要点，即和哪些路由器交换信息？交换什么信息？在什么时候交换信息？
            RIP协议的特点是：
            1）仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP协议规定，不相邻的路由器不交换信息。
            2）路由器交换的信息是当前本路由器所知道的全部信息，即自己的路由表。也就是说，交换的信息是：“我到本自治系统中所有网络的（最短）距离，以及到每个网络应经过的下一跳路由器”。
            3）按固定的时间间隔交换路由信息，例如，每隔30秒。然后路由器根据收到的路由信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。
            这里要强调一点：路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为1）。接着，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。但经过若干次的更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。看起来RIP协议有些奇怪，因为“我的路由表中的信息要依赖于你的，而你的信息又依赖于我的。”然而事实证明，一般情况下，RIP协议可以收敛（convergence），并且过程也比较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程。
            路由表中最主要的信息就是：到某个网络的距离（即最短距离），以及应经过的下一跳地址。路由表更新的原则是找出每个目的网络的最短距离。这种更新算法又称为距离向量算法。下面就是RIP协议使用的距离向量算法。
        2.距离向量算法
        对每一个相邻路由器发送过来的RIP报文，进行一下步骤：
        1）对地址为X的相邻路由器发来的RIP报文，先修改此报文中的所有项目：把“下一跳”字段中的地址都改为X，并把所有的“距离”字段的值加1（见后面的解释1）。每一个项目都有三个关联数据，即：到目的网络N，距离是d，下一跳路由器是X。
        2）对修改后的RIP报文中的每一个项目，进行以下步骤：
            若原来的路由表中没有目的网络N，则把该项目添加到路由表（见解释2）。
                否则（即在路由表中没有目的网络N，这时就再查看下一跳路由器地址）
            若下一跳路由器地址是X，则把收到的项目替换原路由表中的项目（见解释3）。
                否则（即这个项目是：到目的网络N，但下一跳路由器不是X）
            若收到的项目中的距离d小于路由表中的距离，则进行更新（见解释4），
                否则什么也不做。（见解释5）
        3）若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离设置为16（距离为16表示不可达）。
        4）返回。
        上面给出的距离向量算法的基础就是Bellman-Ford算法（或Ford-Fulkerson算法）。这种算法的要点试这样的：
            设X是结点A到B的最短路径上的一个结点。若把路径A→B拆成两段路径A→X和X→B，则每一段路径A→X和X→B也都分别是结点A到X和结点X到B的最短路径。
        下面是对上述距离向量算法的五点解释。
        解释1：这样做是为了便于进行本路由表的更新。假设从位于地址X的相邻路由器发来的RIP报文的某一个项目是：“Net2，3，Y”，意思是“我经过路由器Y到网络Net2的距离是3”，那么本路由器就可推断出：“我经过X到网络Net2的距离应为3+1=4”。于是，本路由器就把收到的RIP报文的这一个项目修改为“Net2，4，X”，作为下一步和路由表中原有项目进行比较时使用（只有比较后才能知道是否需要更新）。读者可注意到，收到的项目中的Y对本路由器是没有用的，因为Y不是本路由器的下一跳路由器地址。
        解释2：表明这是新的目的网络，应当加入到路由表中。例如，本路由表中没有到目的网络Net2的路由，那么在路由表中就要加入新的项目“Net2，4，X”。
        解释3：为什么要替换呢？因为这是最新的消息，要以最新的消息为准。到目的网络的距离有可能增大或减小，但也可能没有改变。例如，不管原来路由表中的项目是“Net2，3，X”还是“Net2，5，X”，都要更新为现在的“Net2，4，X”。
        解释4：例如，若路由表中已有项目“Net2，5，P”，就要更新为“Net2，4，X”。因为到网络Net2的距离原来是5，现在减到4，更短了。
        解释5：若距离更大了，显然不应更新。若距离不变，更新后得不到好处，因此也不更新。
        例4-5已知路由器R6有表4-9（a）所示的路由表。现在收到相邻路由器R4发来的路有更新信息，如表4-9（b）所示。试更新路由器R6的路由表。
                表4-9（a）路由器R6的路由表
                |目的网络|距离|下一跳路由器|
                |Net2    |3   |R4        |
                |Net3    |4   |R5        |
                |···     |··· |···       |
                表4-9（b）R4发来的路由更新信息
                |目的网络|距离|下一跳路由器|
                |Net1    |3   |R1        |
                |Net2    |4   |R2        |
                |Net3    |1   |直接交付   |
            如同路由器一样，我们不需要知道该网络的拓扑。
            先把表b中的距离都加1，并把下一跳路由器都改为R4.得出表4-9（c）。
                表4-9（c）修改后的表4-9（b）
                |目的网络|距离|下一跳路由器|
                |Net1    |4   |R4        |
                |Net2    |5   |R4        |
                |Net3    |2   |R4        |
            把这个表的每一行和表a进行比较。
            第一行在表a中没有，因此要把这一行添加到表a中。
            第二行的Net2在表a中有，且下一跳路由器也是R4.因此要更新（距离增大了）。
            第三行的Net3在表a中有，但下一跳路由器不同。于是就要比较距离。新的路由信息的距离是2，小于原来表中的4，因此要更新。
            这样，得出更新后的R6的路由表如表4-9（d）所示。
                表4-9（d）路由器R6更新后的路由表
                |目的网络|距离|下一跳路由器|
                |Net1    |4   |R4        |
                |Net2    |5   |R4        |
                |Net3    |2   |R4        |
                |···     |··· |···       |
            RIP协议让一个自治系统中的所有路由器都和自己的相邻路由器定期交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）。这里还应该注意：虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，他们的路由表当然也应当是不同的。
        3.RIP协议的报文格式
            现在较新的RIP版本是1998年11月份公布的RIP2（已成为因特网标准协议），新版本协议本身并无多大变化，但性能上有些改进。RIP2可以支持变长子网掩码和CIDR。此外，RIP2还提供简单的鉴别过程支持多播。
            RIP2的报文格式，和RIP1的首部相同，但后面的路有部分不一样。RIP协议使用运输层的用户数据报UDP进行传送（使用UDP的端口520.端口的意义见5.2.2节）。


            RIP报文由首部和路由部分组成。
            RIP的首部占4个字节，其中的命令字段指出报文的意义。例如，1表示请求路由信息，2表示对请求路由信息的响应或未被请求而发出的路由更新报文。首部后面的“必为0”是为了4字字节的对齐。
            RIP2报文中的路有部分由若干个路由信息组成。每个路由信息需要用20个字节。地址族标识符（又称为地质类别）字段用来标识所使用的地址协议。如采用IP地址就令这个字段的值为2（原来考虑RIP也可用于其他非TCP/IP协议的情况）。路由标记填入自治系统号ASN（Autonomous System Number），这是考虑使RIP有可能收到本自治系统以外的路由选择信息。再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及此网络的距离。一个RIP报文最多可包括25个路由，因而RIP报文的最大长度是4+20x25=504字节。如超过，必须再用一个RIP报文来传送。
            RIP2还具有简单的鉴别功能。若使用鉴别功能，则将原来写入第一个路由信息（20字节）的位置用作鉴别。这时应将地址族标识符置为全1（即0xFFFF），而路由标记写入鉴别类型，剩下的16字节为鉴别数据。在鉴别数据之后才写入路由信息，但这时最多只能再放入24个路由信息。
            RIP存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。例子来说明。设三个网络通过两个路由器互连起来，并且都已建立了各自的路由表。路由器R1中的“1，1，直接”表示“到网1的距离是1，直接交付”。路由器R2中的“1，2，R1”表示“到网1的距离是2，下一跳经过R1”。
            现在假定路由器R1到网1的链路出了故障，R1无法到达网1.于是路由器把到网1的距离改为16（表示到网1不可达），因而在R1的路由表中的相应项目变为“1，16，直接”。但是，很可能要经过30秒钟后R1才把更新信息发送给R2。然而R2可能已经先把自己的路由表发送给R1，其中有“1，2，R1”这一项。
            R1收到R2的更新报文后，误认为可经过R2到达网1，于是把收到的路由信息“1，2，R1”修改为：“1，3，R2”，表明“我到网1的距离是3，下一跳经过R2”，并把更新后的信息发送给R2.
            同理，R2接着又更新自己的路由表为“1，4，R1”，以为“我到网1距离是4，下一跳经过R1”。
            这样的更新一直继续下去，知道R1和R2到网1的距离都增大到16时，R1和R2才知道原来网1是不可达的。RIP协议的这一特点叫做：好消息传播的快，而坏消息传播的慢。网络出故障的传播时间往往需要较长的时间（例如数分钟）。这是RIP的一个主要缺点。
            但如果一个路由器发现了更短的路由哦，那么这种更新信息就传播得很快。
            为了使坏消息传播得更快些，可以采取多种措施。例如，让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口反方向传送。
            总之，RIP协议最大的优点就是实现简单，开销较小。但RIP协议的缺点也较多。首先RIP限制了网络的规模，它能使用的最大距离为15（16表示不可达）。其次，路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。最后，“坏消息传播得慢”，使更新过程的收敛时间过长。因此，对于规模较大的网络就应当使用下一节所述的OSPF协议。然而目前在规模较小的网络中，使用RIP协议的仍占多数。
    4.5.3内部网关协议OSPF
        1.OSPF协议的基本特点
        这个协议的名字是开放最短路径优先OSPF（Open Shortest Path First）。它是为克服RIP的缺点在1989年开发出来的。OSPF的原理很简单，但实现起来却较复杂。“开放”表明OSPF协议不是受某一家厂商控制，而是公开发表的。“最短路径优先”是因为使用了Dijkstra提出的最短路径算法SPF。OSPF的第二个版本OSPF2已成为因特网标准协议。
            请注意：OSPF只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。实际上，所有的在自治系统内部使用的路由选择协议都是要寻找一条最短的路径。
        OSPF最主要的特征就是使用分布式的链路状态协议（link state protocol），而不是像RIP那样的距离向量协议。和RIP协议相比，OSPF的三个要点和RIP的都不一样：
            1）向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法（flooding），这就是路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器（但不再发送给刚刚发来信息的那个路由器）。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。更具体的做法后面还要讨论，我们应注意，RIP协议是仅仅向自己相邻的几个路由器发送信息。
            2）发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”（metric）。OSPF将这个“度量”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定，因此较为灵活。有时为了方便就称这个度量为“代价”。我们应注意，对于RIP协议，发送的信息是：“到所有网络的距离和下一跳路由器”。
            3）只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。而不像RIP那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。
            从上述的三个方面可以看出，OSPF和RIP的工作原理相差较大。
        由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库（link-state database），这个数据库实际上就是全网的拓扑结构图。这个拓扑结构图在全网范围内是一致的（这称为链路状态数据库的同步）。因此，每一个路由器都知道全网共有多少个路由器，以及哪些路由器是相连的，其代价是多少，等等。每一个路由器使用链路状态数据库中的数据，构造出自己的路由表（例如，使用Dijkstra的最短路径路由算法）。我们注意到，RIP协议的每一个路由器虽然知道所有的网络的距离以及下一跳路由器，但却不知道全网的拓扑结构（只有到了下一跳路由器，才能知道再下一跳应当怎样走）。
        OSPF的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF的更新过程收敛得快是其重要优点。
        为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫作区域（area）。例，一个自治系统划分为四个区域。每一个区域都有一个32位的区域标识符（用点分十进制表示）。当然，一个区域也不能太大，在一个区域内的路由器最好不超过200个。
        划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。为了使每一个区域能够和本区域以外的区域进行通信，OSPF使用层次结构的区域划分。在上层的区域叫做主干区域（backbone area）。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。从其他区域来的信息都由区域边界路由器（area border router）进行概括。路由器R3，R4和R7都是区域边界路由器，而显然，每一个区域至少应当有一个区域边界路由器。在主干区域内的路由器叫做主干路由器（backbone router），如R3，R4，R5，R6和R7。一盒主干路由器可以同时是区域边界路由器，如R3，R4和R7。在主干区域内还要有一个路由器专门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做自治系统边界路由器。
        采用分层次划分区域的方法虽然使交换信息的种类增多了，同时也使OSPF协议更加复杂了。但这样做却能使每一个区域内部交换路由信息的通信量大大减小，因而使OSPF协议能够用于规模很大的自治系统中。这里，我们再一次地看到划分层次在网络设计中的重要性。
        OSPF不用UDP而是直接用IP数据报传送（其IP数据报首部的协议字段值为89）。OSPF构成的数据报很短。这样做可减少路由信息的通信量。数据报很短的另一个好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。
        OSPF分组使用24字节的固定长度首部，分组的数据部分可以是五种类型分组中的一种。下面简单介绍OSPF首部和字段的意义。
            1）版本    当前的版本号是2.
            2）类型    可以是五种类型分组中的一种。
            3）分组长度    包括OSPF首部在内的分组长度，以字节为单位。
            4）路由器标识符    标志发送该分组的路由器的接口的IP地址。
            5）区域标识符   分组属于的区域的标识符。
            6）检验和   用来检测分组中的差错。
            7）鉴别类型    目前只有两种。0（不用）和1（口令）。
            8）鉴别    鉴别类型为0时就填入0.鉴别类型为1则填入8个字符的口令。

                位0      8     16             31
                  |版本  |类型  |分组长度       |
                  |路由器标识符                 |
                  |区域标识符                   |
                  |检验和       |鉴别类型       |
                  |鉴别                        |
                  |鉴别                        |
              ----------------------------------------------
                              |←--24字节--→|
                              |OSPF分组首部|类型1至类型5的OSPF分组|
              -----------------------------------------------
                  |IP数据报首部|OSPF分组                         |
            除了以上的几个基本特点外，OSPF还具有下列的一些特点：
                1）OSPF对不同的链路可根据IP分组的不同服务类型（TOS）而设置成不同的代价。例如，高带宽的卫星链路对于非实时的业务科设置为较低的代价，但对于时延敏感的业务就可设置为非常高的代价。因此，OSPF对于不同类型的业务科计算出不同的路由。链路的代价可以是1至65535中的任何一个无量纲的数，因此十分灵活。商用的OSPF实现通常是根据链路带宽来计算链路的代价。这种灵活性是RIP所没有的。
                2）如果到同一个目的的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫作多路径间的负载平衡（load balancing）。在代价相同的多条路径上分配通信量是通信量工程中的简单形式。RIP只能找出到某个网络的一条路径。
                3）所有在OSPF路由器之间交换的分组（例如，链路状态更新分组）都具有鉴别的功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。
                4）OSPF支持可变长度的子网划分和无分类的编址CIDR。
                5）由于网络中的链路状态可能经常发生变化，因此OSPF让每一个链路状态都带上一个32位的序号，序号越大状态就越新。OSPF规定，链路转态序号增长的速率不得超过每5秒钟1次。这样，全部序号空间在600年内不会产生重复号。
        2.OSPF的五种分组类型
        OSPF共有以下五种分组类型：
            1）类型1，问候（hello）分组，用来发现和维持邻站的可达性。
            2）类型2，数据库描述（Database Description）分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。
            3）类型3，链路状态请求（Link State Request）分组，向对方请求发送某些链路状态项目的详细信息。
            4）类型4，链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态。这种分组是最复杂的，也是OSPF协议最核心的部分。路由器使用这种分组将其链路状态通知给邻站。链路状态更新分组共有五种不同的链路状态，这里从略。
            5）类型5，链路状态确认（Link State Acknowledgment）分组，对链路更新分组的确认。
        OPF规定，每两个相邻路由器每隔10秒钟要交换一次问候分组。这样就能确知哪些邻站是可达的。对相邻路由器来说，“可达”是最基本的要求，因为只有可达邻站的链路状态信息才存入链路状态数据库（路由表就是根据链路状态数据库计算出来的）。在正常情况下，网络中传送的绝大所述OSPF分组都是问候分组。若有40秒钟没有收到某个相邻路由器发来的问候分组，则可认为该相邻路由器是不可达的，应立即修改链路状态数据库，并重新计算路由表。
        其他的四种分组都是用来进行链路状态数据库的同步。所谓同步就是指不同路由器的链路状态数据库的内容是一样的。两个同步的路由器叫做“完全邻接的”（fully adjacent）路由器。不是完全邻接的路由器表明它们虽然在物理上是相邻的，但其链路状态数据库并没有达到一致。
        当一个路由器刚开始工作时，它只能通过问候分组得知它有哪些相邻的路由器在工作，以及将数据发往相邻路由器所需的“代价”。如果所有的路由器都把自己的本地链路状态信息对全网进行广播，那么各路由器只要将这些链路状态信息综合起来就可得出链路状态数据库。但这样做开销太大，因此OSPF采用下面的办法。
        OSPF让每一个路由器用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息。摘要信息主要就是指出有哪些路由器的链路状态信息（以及其序号）已经写入了数据库。经过与相邻路由器交换数据库描述分组后，路由器就使用链路状态请求分组，向对方请求发送自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网同步的链路数据库就建立了。OSPF的基本操作，说明了两个路由器需要交换各种类型的分组。
                -------------------R================R
                确定可达性           ------问候-----→
                                    ←-----问候------
                -----------------------------------------
                达到数据库的同步     -----数据库描述-→
                                    ←---数据库描述---
                                    ----数据库描述--→
                                    ←---数据库描述---
                ------------------------------------------
                新情况下的同步       ---链路状态请求---→
                                    ←--链路状态更新----
                                    ---链路状态确认---→
                ------------------------------------------
        在网络运行的过程中，只要一个路由器的链路状态发生变化，该路由器就要使用链路状态更新分组，用洪泛法向全网更新链路状态。OSPF使用的是可靠的洪泛法。设路由器R用洪泛法发出链路状态更新分组。第一次先发给相邻的三个路由器。这三个路由器将收到的分组再进行转发时，要将其上游路由器除外。可靠的洪泛法是在收到更新分组后要发送确认（收到重复的更新分组只需要发送一次确认）。
        为了确保链路状态数据库与全网的状态保持一致，OSPF还规定每隔一段时间，如30分钟，要刷新一次数据库中的链路状态。
        由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好得多。由于OSPF没有“坏消息传播得慢”的问题，据统计，其相应网络变化的时间小于100ms。
        若N和路由器连接在一个以太网上，则每个路由器要向其他（N-1）个路由器发送链路状态信息，因而共有（N-1）^2个链路状态要在这个以太网上传送。OSPF协议对这种多点接入的局域网采用了指定的路由器（designated router）的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。
    4.5.4外部网关协议BGP
    1989年，公布了新的外部网关协议--边界网关协议BGP。BGP是不同AS的路由器之间交换路由信息的协议。为简单起见，后面我们把BGP-4都简写为BGP。
    我们首先应当弄清，在不同AS之间的路由选择为什么不能使用前面讨论过的内部网关协议，如RIP或OSPF？
    我们知道，内部网关协议（如RIP或OSPF）主要是设法使数据报在一个AS中尽可能有效地从源站传送到目的站。在一个AS内部也不需要考虑其他方面的策略。然而BGP使用的环境却不同。这主要是因为一下的两个原因：
        第一，因特网的规模太大，使得AS之间路由选择非常困难。连接在因特网主干网上的路由器，必须对任何有效的IP地址都能在路由表中找到匹配的目的网络。目前在因特网的主干网路由器中，一个路由表的项目数早已超过了5万个网络前缀。如果使用链路状态协议，则每一个路由器必须维持一个很大的链路状态数据库。对于这样打的主干网用Dijkstra算法计算最短路径时花费的时间也太长。另外，由于AS各自运行自己选定的内部路由选择协议，并使用本AS指明的路径度量，因此，当一条路径通过几个不同AS时，要想对这样的路径计算出有意义的代价是不太可能的。例如，对某AS来说，代价为1000可能表示一条比较长的路由。但对另一AS代价为1000却可能表示不可接受的坏路由。因此，对于AS之间的路由选择，要用“代价”作为度量来寻找最佳路由也是很不现实的。比较合理的做法是在AS之间交换“可达性”信息（即“可达性”或“不可达性”）。例如，告诉相邻路由器：“到达目的网络N可经过ASx”。
        第二，AS之间的路由选择必须考虑有关策略。由于相互连接的网络的性能相差很大，如果根据最短距离（即最少跳数）找出来的路径，可能并不合适。也有的路径的使用代价很高或很不安全。还有一种情况，如AS1要发送数据报给AS2，本来最好是经过AS3。但AS3不愿意让这些数据报通过本AS的网络，因为“这是他们的事情，和我们没有关系。”但另一方面，AS3愿意让某些相邻AS的数据报通过自己的网络，特别是对那些付了服务费的某些AS更是如此。因此，AS之间的路由选择协议应当允许使用多种路由选择策略。这些策略包括政治、安全或经济方面的考虑。例如，我国国内的站点在互相传送数据报时不应经过国外兜圈子，特别是，不要经过某些对我国的安全有威胁的国家。这些策略都是由网络管理人员对每一个路由器进行设置的，但这些策略并不是AS之间的路由选择协议本身。还可举出一些策略的例子，如：“仅在到达下列这些地址时才经过ASx”，“ASx和ASy相比时应优先通过ASx”，等等。显然，使用这些策略是为了找出较好的路径而不是最佳路径。
    由于上述情况，边界网关协议BGP只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。BGP采用了路径向量（path vector）路由选择协议，它与距离向量协议和链路状态协议都有很大的区别。
    在配置BGP时，每一个AS的管理员要选择知道一个路由器作为该AS的“BGP发言人”。一般来说，两个BGP发言人都是通过一个共享网络连接在一起的，而BGP发言人往往就是BGP边界路由器，但也可以不是BGP边界路由器。
    一个BGP发言人与其他AS的BGP发言人要交换路由信息，就要先建立TCP连接（端口号为179），然后在此连接上交换BGP报文以建立BGP会话（session），利用BGP会话交换路由信息，如增加了新的路由，或撤销过时的路由，以及报告出差错的情况等等。使用TCP连接能提供可靠的服务，也简化了路由选择协议。使用TCP连接交换路由信息的两个BGP发言人，彼此成为对方的邻站（neighbor）或对等站（peer）。
    每一个BGP发言人除了必须运行BGP协议外，还必须运行该AS所使用的内部网关协议，如OSPF或RIP。
    BGP所交换的网络可达性的信息就是要到达某个网络（用网络前缀表示）所要经过的一系列AS。当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由。AS连通图，是树形结构，不存在回路。
    在第1章的1.2.2节我们已经介绍了当前因特网的多级结构特点。这种多级结构的网络拓扑决定了BGP路由选择协议的特点。
    一个BGP发言人交换路由向量的例子。自治系统AS2的BGP发言人通知主干网的BGP发言人：“要到达网络N1，N2，N3和N4可经过AS2”。主干网在收到这个通知后，就发出通知：“要达到网络N1，N2，N3和N4可沿路径（AS1，AS2）。”同理，主干网还可发出通知：“要到达网络N5，N6和N7可沿路径（AS1，AS3）。”
    从上面的讨论课看出，BGP协议交换路由信息的结点数量级是自治系统AS数的量级，这要比这些AS中的网络数少很多。要在许多AS之间寻找一条较好的路径，就是要寻找正确的BGP发言人（或边界路由器），而在每一个AS中BGP发言人（或边界路由器）的数量是很少的。这样就使得AS之间的路由选择不致过分复杂。
    BGP支持CIDR，因此BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的AS序列。由于使用了路径向量的信息，就可以很容易地避免产生兜圈子的路由。如果一个BGP发言人收到了其他BGP发言人发来的路径通知，它就要检查一下AS是否在此通知的路径中。如果在这条路径中，就不能采用这条路径（因为会兜圈子）。
    在BGP刚刚运行时，BGP的邻站是交换整个的BGP路由表。但以后只需要发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。
        在RFC4271中规定了BGP-4的四种报文：
        1）OPEN（打开）报文，用来与相邻的另一个BGP发言人建立关系，使通信初始化。
        2）UPDATE（更新）报文，用来通告某一路由的信息，以及列出要撤销的多条路由。
        3）KEEPALIVE（保活）报文，用来周期性地证实邻站的连通性。
        4）NOTIFICATION（通知）报文，用来发送检测到的差错。
        在RFC2918中增加了ROUTE-REFRESH报文，用来请求对等端重新通告。
    若两个邻站属于两个不同AS，而其中一个邻站打算和另一个邻站定期地交换路由信息，这就应当有一个商谈的过程（因为很可能对方路由器的负荷已很重因而不愿意再家中负担）。因此，一开始向邻站进行商谈时就必须发送OPEN报文。如果邻站接收这种邻站关系，就用KEEPALIVE报文响应。这样，两个BGP发言人的邻站关系就建立了。
    一旦邻站关系建立了，就要继续维持这种关系。双方中的每一方都需要确信对方是存在的，且一直在保持这种邻站关系。为此，这两个BGP发言人彼此要周期性地交换KEEPALIVE报文（一般每隔30秒）。KEEPALIVE报文只有19字节长（只用BGP报文的通用首部），因此不会造成网络上太大的开销。
    UPDATE报文是BGP协议的核心内容。BGP发言人可以用UPDATE报文撤销它以前曾经通知过的路由，也可以宣布增加新的路由。撤销路由可以一次撤销许多条，但增加新路由时，每个更新报文只能增加一条。
    BGP可以很容易地解决距离向量路由选择算法中的“坏消息传播得慢”这一问题。当某个路由器或链路出故障时，由于BGP发言人可以从不止一个邻站获得路由信息，因此很容易选择出新的路由。距离向量算法往往不能给出正确的选择，是因为这些算法不能指出哪些邻站到目的站的路由是独立的。
    BGP报文的格式。四种类型的BGP报文具有同样的通用首部，其涨肚为19字节。通用首部分为三个字段。标记（marker）字段为16字节长，用来鉴别收到的BGP报文（这是假定将来有人会发明出合理的鉴别方案）。当不实用鉴别是，标记字段要置为全1。长度字段指出包括通用首部在内的整个BGP报文以自己为单位的长度，最小值是19，最大值时4096。乐行字段的值为1到4，分别对应于上述四种BGP报文中的一种。
    OPEN报文共有6个字段，即版本（1字节，现在的值是4）、本自治系统号（2字节，使用全球唯一的16位自己系统号，有ICANN地区登记机构分配）、保持时间（2字节，以秒计算的保持为邻站关系的时间）、BGP标识符（4字节，通常就是该路由器的IP地址）、可选参数长度（1字节）和可选参数。
    UPDATE报文共有5个字段，即不可行路由长度（2字节，指明下一个字段的长度）、撤销的路由（列出所有要撤销的路由）、路径属性总长度（2字节，指明下一个字段的长度）、路径属性（定义在这个报文中增加的路径属性）和网络层可达性信息NLRI（Network Layer Reachability Information）。最后这个字段定义发出此报文的网络，包括网络前缀的位数、IP地址前缀。
    KEEPALIVE报文只有BGP的19字节长的通用首部。
    NOTIFICATION报文有3个字段，即差错代码（1字节）、差错子代码（1字节）和差错数据（给出有关差错的诊断信息）。RFC2918定义的ROUTE-REFRESH报文只有4字节长，不采用上述的BGP报文格式。
    在讨论完路由选择时候，我们再来介绍路由器的构成。
    4.5.5路由器的构成
        1.路由器的结构
        路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。从路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。下一跳路由器也按照这种方法处理分组，直到该分组到达终点为止。路由器的转发分组正式网络层的主要工作。一种典型的路由器的构成框图。
                        |  路由选择处理机   |         ↑
                        |  |路由选择协议|   |      路由选择
                        |      路由表      |         ↓
                --------------------------------------------
                输入端口 ------------------- 输出端口   ↑
              |1，2，3|→|   |分组处理 |    |→|3，2，1|  |
                        |   ||转发表| |    |         分组转发
                        |   ----------    |           |
              |1，2，3|→|    交换结构      |→|3，2，1|  ↓
                        -------------------
        从中看出，整个的路由器结构可划分为两大部分：路由选择部分和分组转发部分。
        路由选择部分也叫做控制部分，其核心构件是路由选择处理机。路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。关于怎样根据路由选择协议构造和更新路由表，我们将在后面几节详细讨论。
        分组转发部分是本节所要讨论的问题，它由三部分组成：交换结构、一组输入端口和一组输出端口（请注意：这里的端口就是硬件接口）。下面分别讨论每一部分的组成。
        交换结构（switching fabric）又称为交换组织，它的作用就是根据转发表（forwarding table）对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去。交换结构本身就是一种网络，但这种网络完全包含在路由器之中，因此交换结构可看成是“在路由器中的网络”。
        请注意“转发”和“路由选择”是有区别的。在互联网中，“转发”就是路由器根据转发表把收到的IP数据报从路由器合适的端口转发出去。“转发”仅仅涉及到一个路由器。但“路由选择”则涉及到很多路由器，路由表则是许多路由器协同工作的结构。这些路由器按照复杂的路由算法，得出整个网络的拓扑变化情况，因而能够动态地改变所选择的路由，并由此构造出整个的路由表。路由表一般仅包含从目的网络到下一跳（用IP地址表示，下一节就讨论什么是IP地址）的映射，而转发表时从路由表得出的。转发表必须包含完成转发功能所必须的信息。这就是说，在转发表的每一行必须包含从要到达的目的网络到输出端口和某些MAC地址信息（如下一跳的以太网地址）的映射。将转发表和路由表不同的数据结构实现会带来一些好处，这是因为在转发分组时，转发表的结构应当使查找过程最优化，但路由表则需要对网络拓扑变化的计算最优化。路由表总是用软件实现的，但转发表则甚至可用特殊的硬件来实现。请读者注意，在讨论路由选择的原理时，往往不去区分转发表和路由表的区别，而可以笼统地都使用路由表这一个名词。
        在图中，路由器的输入和输出端口里面都各有三个方框，用方框中的1，2和3分别代表物理层、数据链路层和网路层的处理模块。物理层进行比特的接受。数据链路层则按照链路层协议接收传送分组的帧。在把帧的首部和尾部剥去后，分组就被送入网络层的处理模块。若接收到的分组是路由器之间交换路由信息的分组（如RIP或OSPF分组等），则把这种分组送交路由器的路由选择部分中的路由选择处理机。若接收到的是数据分组，则按照分组首部中的目的地址查找转发表，根据得出的结果，分组就经过交换结构到达合适的输出端口。一个路由器的输入端口和输出端口就做在路由器的线路接口卡上。
        输入端口中的查找和转发功能在路由器的交换功能中是最重要的。为了使交换功能分散化，往往把复制的转发表放在每一个输入端口中。路由选择处理机负责对个转发表的副本进行更新。这些副本常称为“影子副本”（shadow copy）。分散化交换可以避免在路由器中的某一点上出现瓶颈。
        以上介绍的查找转发表和转发分组的概念虽然并不复杂，但在具体的实现中还是会遇到不少困难。问题就在于路由器必须以很高的速率转发分组。最理想的情况是输入端口的处理速率能够跟上线路把分组传送到路由器的速率。这种速率称为线速（line speed或wire speed）。可以粗略地估算一下。设线路是OC-48链路，即2.5Gb/s。若分组长度256字节，那么线速就应当达到每秒能够处理100万以上的分组。现在常用的Mpps（百万分组每秒）为单位来说明一个路由器对收到的分组的处理速率有多高。在路由器的设计中，怎样提高查找转发表的速率是一个十分重要的研究课题。
        当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到另一个分组。这个后到的分组就必须在队列中排队等待，因而产生了一定的时延。在输入端口的队列中排队的分组的示意图。
                输入端口的处理：
                从线路接收分组→{→{物理层处理}→{数据链路层处理}→{网络层处理分组排队{查表和转发}}}→交换结构
        我们再来观察在输出端口上的情况。输出端口从交换结构接收分组，然后把它们发送到路由器外面的线路上。在网络层的处理模块中设有一个缓冲区，实际上它就是一个队列。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须暂时存放在这个队列中。数据链路层处理模块把分组加上链路层的首部和尾部，交给物理层后发送到外部线路。
                输出端口的处理：
                交换结构→{→{网络层处理分组排队{缓存管理}}→{数据链路层处理}→{物理层处理}→}→向线路发送分组
        从以上的讨论可以看出，分组在路由器的输入端口和输出端口都可能会在队列中排队等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。以前我们提到过的分组丢失就是发生在路由器中的输入或输出队列产生溢出的时候。当然，设备或线路出故障也可能使分组丢失。
        2.交换结构
        交换结构是路由器的关键构建。正是这个交换结构将分组从一个输入端口转移到某个合适的输出端口。实现这样的交换有多种方法，三种常用的交换方法。这三种方法都是输入端口I1收到的分组转发到输出端口O2。下面简单介绍它们的特点。
        最早使用的路由器就是利用普通的计算机，用计算机的CPU作为路由器的选择处理机。路由器的输入和输出端口的功能和传统的操作系统的I/O设备一样。当路由器的某个输入端口收到一个分组时，就用中断方式通知路由选择处理机。然后分组就从输入端口复制到存储器中。路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适的输出端口的缓存中。若存储器的带宽（读或写）为每秒M个分组，那么路由器的交换速率（即分组从输入端口传送到输出端口的速率）一定小于M/2。这是因为存储器对分组的读和写需要花费的时间是同一个数量级。
        许多现代的路由器也通过存储器进行交换，分组通过存储器进行交换。与早期的路由器的区别就是，目的地址的查找和分组在存储器中的缓存都是在输入端口中进行的。Cisco公司的Catayst 8500系列交换机（有的公司把路由器也称为交换机）和Bay Network公司的Accelar 1200系列路由器就采用了共享存储器的方法。
        通过总线进行交换。采用这种方式时，数据报从输入端口通过共享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预。但是，由于总线是共享的，因此在同一时间只能有一个分组在总线上传送。当分组到达输入端口若发现总线忙（因为总线正在传送另一个分组），则被阻塞而不能通过交换结构，并在输入端口排队等待。因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的限制。现代的技术已经可以将总线的带宽提高到每秒吉比特的速率，因此许多的路由器产品都采用这种通过总线的交换方式。例如，Cisco公司的Catalyst 1900系列交换机就使用了带宽达到1Gb/s的总线（叫做Packet Exchange Bus）。
        通过纵横交换结构（crossbar switch fabric）进行交换。这种交换机构常称为互联网络（interconnection network），它有2N条总线，可以使N个输入端口和N个输出端口相连接，这取决于相应的交叉结点是使水平总线和垂直总线接通还是断开。当输入端口接收到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个输出端口。但若该垂直总线已被占用（有另一个分组正在转发到同一个输出端口），则后到达的分组就被阻塞，必须在输入端口排队。采用这种交换方式的路由器例子是Cisco公司的12000系列交换路由器，它使用的互联网络的带宽达60Gb/s。
4.6  IP多播
    4.6.1 IP多播的基本概念
        1988年Steve Deering首次在其博士学位论文中提出IP多播的概念。1992年3月IETF在因特网范围首次试验IETF会议声音的多播，当时有20个网店可同时听到会议的声音。IP多播是需要在因特网上增加更多的智能才能提供的一种服务。现在IP多播（multicast，以前曾译为组播）已成为因特网的一个热门课题。这是由于有许多的应用需要由一个源点发送到许多个重点，即一对多的通信。例如，实时信息的交付（如新闻、股市行情等），软件更新，交互式会议等。随着因特网的用户数目的急剧增加，以及多媒体通信的开展，有更多的业务需要多播来支持。关于IP多播可参考[W-MCAST]。
        与单播相比，在一对多的通信中，多播可大大节约网络资源。视频服务器用单播方式向90个主机传送同样的视频节目。为此，需要发送90个单播，即同一个视频分组要发送90个副本。视频服务器用多播方式向属于同一个多播组的90个成员查宿弄节目。这时，视频服务器只需把视频分组当做多播数据报来发送，并且只需发送一次。路由器R1在转发分组时，需要把收到的分组复制成3个副本，分别向R2，R3和R4各转发1个副本。当分组到达目的局域网时，由于局域网具有硬件多播功能，因此不需要复制分组，在局域网上的多播成员都能收到这个视频分组。
        当多播组的主机数很大时（如成千上万个），采用多播方式可明显减轻网络中各种资源的消耗。在因特网范围的多播要靠路由器来实现，这些路由器必须增加一些能够识别多播数据报的软件。能够运行多播协议的路由器称为多播路由器（multicast router）。多播路由器当然也可以转发普通的单播IP数据报。
        为了适应交互式音频和视频信息的多播，从1992年起，在因特网上开始试验虚拟的多播主干网MBONE（Multicast Backbone On the InterBEt）。MBONE可把分组传播地点分散但属于一个组的许多个主机。现在多播主干网已经有了相当大的规模。
        在因特网上进行多播就叫做IP多播。IP多播所传送的分组需要使用多播IP地址。
        我们知道，在因特网中每一个主机必须有一个全球唯一的IP地址。如果某个主机现在想接受某个特定多播组的分组，那么怎样才能使这个多播数据报传送到这个主机？
        显然，这个多播数据报的目的地址一定不能写入这个主机的IP地址。这是因为同一个时间可能有成千上万个主机加入到听一个多播组。多播数据报不可能在其首部写入这样多的主机的IP地址。在多播数据报的目的地址写入的是多播组的标识符，然后设法加入到这个多播组的主机的IP地址与多播组的标识符关联起来。
        其实多播组的标识符就是IP地址中的D类地址。D类IP地址的前四位是1110，因此D类地址范围是224.0.0.0到239.255.255.255。我们就用每一个D类地址标志一个多播组。这样，D类地址共可标志2^28个多播组。多播数据报和一般的IP数据报的区别就是它使用D类IP地址作为目的地址，并且首部中的协议字段值是2，表明使用IGMP协议。
        显然，多播地址只能用于目的地址，而不能用于源地址。此外，对多播数据报不产生ICMP差错报文。因此，若在PING命令后面键入多播地址，将永远不会收到响应。
        D类地址中有一些是不能随意使用的，因为有的地址已经被IANA指派为永久组地址了。例如：
                224.0.0.0基地址（保留）
                224.0.0.1在本子网上的所有参加多播的主机和路由器
                224.0.0.2在本子网上所有参加多播的路由器
                224.0.0.3未指派
                ······
                224.0.0.4DVMRP路由器
                ······
                224.0.1.0至238.255.255.255全球范围都可使用的多播地址
                239.0.0.0至239.255.255.255限制在一个组织的范围
        IP多播可以分为两种。一种是只在本局域网上进行硬件多播，另一种则是在因特网的范围进行多播。前一种虽然比较简单，但很重要，因为现在大部分主机都是通过局域网接入到因特网的。在因特网上进行多播的最后阶段，还是要把多播数据报在局域网上用硬件多播交付给多播组的所有成员。下面就先讨论这种硬件多播。
    4.6.2在局域网上进行硬件多播
        因特网号码指派管理局IANA拥有的以太网地址块的高24位为00-00-5E，因此TCP/IP协议使用的以太网多播地址块的范围是从00-00-5E-00-00-00到00-00-5E-FF-FF-FF。在3.4.3节已讲过，以太网硬件地址字段中的第1字节的最低位为1时即为多播地址，这种躲避地址数占IANA分配到的地址数的一半。因此IANA拥有的以太网多播地址的范围是从01-00-5E-00-00-00到01-00-5E-7F-FF-FF。不难看出，在每一个地址中，只有23位可用作多播。这只能和D类IP地址中的23位有一一对应的关系。D类IP地址可供分配的有28位，可见在这28位中的前5位不能用来构成以太网硬件地址。例如，IP多播地址224.128.64.32（即E0-80-40-20）和另一个IP多播地址224.0.64.32（即E0-00-40-20）转换成以太网的硬件多播地址都是01-00-5E-00-40-20。由于多播IP地址与以太网硬件地址的映射关系不是唯一的，因此收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本主机要接收的数据报丢弃。
        下面就讨论进行IP多播所需要的协议。
    4.6.3网际组管理协议IGMP和多播路由选择协议
        1.IP多播需要两种协议
        因特网上传送多播数据报的例子。四个主机都参加了一个多播组，其组地址是226.15.37.123。显然，多播数据报应当传送到路由器R1，R2和R3，而不应当传送到路由器R4，因为与R4连接的局域网上现在没有这个多播组的成员。但这些路由器又怎样知道多播组的成员信息呢？这就要利用一个协议，叫做网际组管理协议IGMP（Internet Group Management Protocol）。
        强调IGMP的本地使用范围。请注意，IGMP并非在因特网范围内对所有多播组成员进行管理的协议。IGMP不知道IP多播组包含的成员数，也不知道这些成员都分布在哪些网络上，等等。IGMP协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。
        显然，仅有IGMP协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和因特网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用多播路由选择协议。
        然而多播路由选择协议要比单播路由选择协议复杂得多。我们可以通过一个简单的例子来说明。
        我们假定有两个多播组。多播组1的成员主机有A，B和C，而多播组2的成员有主机D，E和F、这些主机分布在三个网络上（N1，N2和N3）。
        路由器R不应当向网络N3转发多播组1的分组，因为网络N3上没有多播组1的成员。但是每一个主机可以随时加入或离开一个多播组。例如，主机G现在加入了多播组1。从这时起，路由器R就必须也向网络N3转发多播组1的分组。这就是说，多播转发必须动态地适应多播成员的变化（这时网络拓扑并未发生变化）。请注意，单播路由选择通常是在网络拓扑发生变化时才需要更新路由。
        再看一种情况。主机E和F都是多播组2的成员。当E向F发送多播数据报时，路由器R把这个多播数据报转发到网络N3。但当F向E发送多播数据报时，路由器R则把多播数据报转发到网络N2。如果路由器R收到来自主机A的多播数据报（A不是多播组2的成员，但也可向多播组发送多播数据报），那么路由器R就应当把多播数据报转发到N2和N3.由此可见，多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，而是还要考虑这个多播数据报从什么地方来合要到什么地方去。
        还有一种情况。主机G没有参加任何多播组，但G却可向任何多播组发送多播数据报。例如，G可向多播组1或2发送多播数据报。主机G所在的局域网上可以没有任何多播组的成员。显然，多播数据报所经过的许多网络，也不一定非要有多播组成员。总之，多播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络。
        正因为如此，IP多播就成为比较复杂的问题。下面介绍这两种协议的要点。
        2.网际组管理协议IGMP
        IGMP已有了三个版本。1089年公布的RFC 1112早已成为了因特网的标准协议。1997年公布的RFC 2236（IGMPv2，建议标准）对IGMPv1进行了更新。2002奶奶10月公布了RFC 3376（IGMPv3，建议标准），宣布RFC 2236（IGMPv2）是陈旧的。
        和IGMP相似，IGMP使用IP数据报传递其报文（即IGMP报文加上IP首部构成IP数据报），但它也向IP提供服务。因此，我们不把IGMP看成是一个单独的协议，而是属于整个网际协议IP的一个组成部分。
        从概念上讲，IGMP的工作可分为两个阶段。
        第一阶段：当某个主机加入新的多播组时，该主机应向多播组的多播地址发送一个IGMP报文，声明自己要成为该组的成员。本地的多播路由器收到IGMP报文后，还要利用多播路由选择协议把这种组成员关系转发给因特网上的其他多播路由器。
        第二阶段：组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。只要有一个主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一个主机响应，多播路由器就认为本网络上的主机已经都离开这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。
        IGMP设计得很仔细，避免了多播控制信息给网络增加大量的开销。IGMP采用的一些具体措施如下：
            1）在主机和多播路由器之间的所有通信都是使用IP多播。只要有可能，携带IGMP报文的数据报都用硬件多播来传送。因此在支持硬件多播的网络上，没有参加IP多播的主机不会收到IGMP报文。
            2）多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，而不需要对每一个组发送一个询问报文（虽然也允许对一个特定组发送询问报文）。默认的询问速率是每125秒发送一次（通信量并不太大）。
            3）当同一个网络上连接有几个多播路由器时，他们能够迅速和有效地选择其中一个来探询主机的成员关系。因此，网络上多个多播路由器并不会引起IGMP通信量的增大。
            4）在IGMP的询问报文中有一个数值N，它指明一个最长响应时间（默认值为10秒）。当收到询问时，主机在0到N之间随机选择发送响应所需经过的时延。因此，若一个主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的响应最先发送。
            5）同一个组内的每一个主机都要监听响应，只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。这样就抑制了不必要的通信量。
        多播路由器并不需要保留组成员关系的准确记录，因为向局域网上的组成员转发数据报是使用硬件多播。多播路由器只需要知道网络上是否至少还有一个主机是本组成员即可。对询问报文实际上每一个组只要一个主机发送响应。
        如果一个主机上有多个进程都加入了某个多播组，那么这个主机对发给这个多播组的每个多播数据报只接收一个副本，然后给主机中的每一个进程发送一个本地复制的副本。
        最后我们还要强调指出，多播数据报的发送者和接收者都不知道（也无法找出）一个多播组的成员有多少，以及这些成员是哪些主机。因特网中的路由器和主机都不知道哪个应用进程将要向哪个多播组发送多播数据报，因为任何应用进程都可以在任何时候向任何一个多播组发送多播数据报，而这个应用进程并不需要加入这个多播组。
        IGMP的报文格式可参阅有关文档RFC 3376。
        3.多播路由选择协议
        虽然在TCP/IP中IP多播协议已成为建议标准，但多播路由选择协议（用来在多播路由器之间传播路由信息）则尚未标准化。
        在多播过程中一个多播组中的成员是动态变化的。例如在收听网上某个广播节目时，随时会有主机加入或离开这个多播组。多播路由选择实际上就是要找出源主机为根节点的多播转发树。在多播转发树上，每一个多播路由器向树的叶节点方向转发收到的多播数据报，但在多播转发树上的路由器不会收到重复的多播数据报（即多播数据报不应在互联网中兜圈子）。不难看出，对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的源点也会有不同的多播转发树。
        已有了多种实用的多播路由选择协议，他们在转发多播数据报时使用了以下的三种方法：
            1）洪泛与剪除。这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相邻接的。一开始，路由器转发多播数据报使用洪泛的方法（这就是广播）。为了避免兜圈子，采用了叫做反向路径广播RPB（Reverse Path Broadcasting）的策略。RPB的要点试：每一个路由器在收到一个多播数据报时，先检查数据报是否从源点经最短路径传送来的。进行这种检查很容易，只要从本路由器寻找到源点的最短路径上（之所以叫做反向路径，因为在计算最短路径时是把源点当做终点）的第一个路由器是否就是刚才把多播数据报送来的路由器。若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外），否则就丢弃而不转发。如果本路由器有好几个相邻路由器都处在到源点的最短路径上（也就是说，存在几条同样长度的最短路径），那么只能选择一条最短路径，选择的准则就是看这几条最短路径中的相邻路由器谁的IP地址最小。
            为简单起见，网络用路由器之间的链路来表示。我们假定个路由器之间的距离都是1.路由器R1收到源点发来的多播数据报后，向R2和R3转发。R2发现R1就在自己到源点的最短路径上，因此向R3和R4转发收到的数据报。R3发现R2不在自己到源点的最短路径上，因此丢弃R2发来的数据报。其他路由器也这样转发。R7到源点有两条最短路径：R7→R4→R2→R1→源点：R7→R5→R3→R1→源点。我们再假定R4的IP地址比R5的IP地址小，所以我们只使用前一条最短路径。因此R7只转发R4传过来的数据报，而丢弃R5传过来的数据报。最后就得出了用来转发多播数据报的多播转发树，以后就按这个多播转发树来转发多播数据报。这样就避免了多播数据报的兜圈子，同时每一个路由器也不会接收重复的多播数据报。
            如果在多播转发树上的某个路由器发现它的下游树枝（即叶节点方向）已没有该多播组的成员，就应把它和下游的树枝一起剪除。当某个树枝有新增加的组成员时，可以再接入到多播转发树上。
            2）隧道技术（tunneling）。隧道技术适用于多播组的位置在地理上很分散的情况。例如网1和网2都支持多播。现在网1中的主机向网2中的一些主机进行多播。但路由器R1和R2之间的网络并不支持多播，因而R1和R2不能按多播地址转发数据报。为此，路由器R1就对多播数据报进行再次封装，即再加上普通数据报首部，使之成为向单一目的站发送的单播（unicast）数据报，然后通过“隧道”（runnel）从R1发送到R2。
            单播数据报到达路由器R2后，再由路由器R2剥去其首部，使它又恢复成原来的多播数据报，继续向多个目的站转发。这一点和英吉利海峡隧道运送汽车的情况相似。英吉利海峡隧道不允许汽车在隧道中行驶。但是，可以把汽车放置在隧道中行驶的电气火车上来通过隧道。过了隧道后，汽车有可以继续在公路上行驶。这种使用隧道的技术传送数据报又叫做IP中的IP（IP-in-IP）。
            3）基于核心的发现技术。这种方法对于多播组的大小在较大范围内变化时都适合。这种方法是对每一个多播组G指定一个核心（core）路由器，给出它的IP单播地址。核心路由器按照前面讲过的方法创建出对应于多播组G的转发树。如果有一个路由器R1向这个核心路由器发送数据报，那么它在途中经过的每一个路由器都要检查其内容。当数据报到达参加了多播组G的路由器R2时，R2就处理这个数据报。如果R1发出的是一个多播数据报，其目的地址是G的组地址，R2就向多播组G的成员转发这个多播数据报。如果R1发出的数据报时一个请求加入多播组G的数据报，R2就把这个信息加到它的路由中，并用隧道技术向R1转发每一个多播数据报的一个副本。这样，参加到多播组G的路由器就从核心向外增多了，扩大了多播转发树的覆盖范围。
            目前还没有在整个因特网范围使用的多播路由选择协议。下面是一些建议使用的多播路由选择协议。
        距离向量多播路由选择协议DVMRP（Distance Vector Multicast Routing Protocol）是在因特网上使用的第一个多播路由选择协议。由于在UNIX系统中实现RIP的程序叫做routed，所以在routed的前面加表示多播的字母m，叫做mrouted，它使用DVMRP在路由器之间传播路由信息。
        机遇和新的转发数CBT（Core Based Tree）。这个协议使用核心路由器作为转发树的根节点。一个大的自治系统AS可划分为几个区域，每一个区域选择一个核心路由器（也叫做中心路由器center router，或汇聚点路由器rendezvous router）。
        开放最短通路优先的多播扩展MOSPF（Multicast extensions to OSPF）。这个协议是单播路由选择协议OSPF的扩充，使用于一个机构内。MOSPF使用多播链路状态路由选择创建基于源点的多播转发树。
        协议无关多播-稀疏方式PIM-SM（Protocol Independent Multicast-Sparse Mode）。这个协议使用和CBT同样的方法构成多播转发树。采用“协议无关”这个名词是强调：虽然在建立多播转发树时是使用单播数据报来合远程路由器联系，但这并不是要求使用特定的单播路由选择协议。这个协议适用于组成员的分布非常分散的情况。
        协议无关多播-密集方式PIM-DM（Protocol Independent Multicast-Dense Mode）。这个协议适用于组成员的分布非常集中的情况，例如组成员都在一个机构之内。PIM-DM不使用核心路由器，而是使用洪泛方式转发数据报。
4.7虚拟专用网VPN和网络地址转换NAT
    4.7.1虚拟专用网VPN
    由于IP地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。考虑到因特网并不很安全，一个机构内也并不需要把所有的主机接入到外部的因特网。实际上，在许多情况下，很多主机主要还是金额本机构内的其他主机进行通信（例如，在大型商场或宾馆中，有很多用于营业和管理的计算机。显然这些计算机并不都需要和因特网相连）。假定在一个机构内部的计算机通信也是采用TCP/IP协议，那么从原则上讲，对于这些仅在机构内部使用的计算机就可以由本机构自行分配其IP地址。这就是说，让这些计算机使用仅在本机构有效的IP地址（这种地址称为本地地址），而不需要向因特网的管理机构申请全球唯一的IP地址（这种地址称为全球地址）。这样就可以大大节约宝贵的全球IP地址资源。
    但是，如果任意选择一些IP地址作为本机构内部使用的本地地址，那么在某种情况下可能会引起一些麻烦。例如，有时机构内部的某个主机需要和因特网连接，那么这种仅在内部使用的本地地址就有可能和因特网中某个IP地址重合，这样就会出现地址的二义性问题。
    为了解决这一问题，RFC 1918指明了一些专用地址（private address）。这些地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。换言之，专用地址只能用作本地地址而不能用作全球地址。在因特网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。RFC 1918指明的专用地址是：
        1）10.0.0.0到10.255.255.255（或记为10/8，它又称为24位块）
        2）172.16.0.0到172.31.255.255（或记为172.16/12，它又称为20位块）
        3）192.168.0.0到192.168.255.255（或记为192.168/16，它又称为16位块）
        上面的三个地址块分别相当于一个A类网络、16个连续的B类网络和256个连续的C类网络。A类地址本来早已用完了，而上面的地址10.0.0.0本来是分配给ARPANET的。由于ARPANET已经关闭停止运行了，因此这个地址就用作专用地址。
        采用这样的专用IP地址的互联网络称为专用互联网或本地互联网，或更简单些，就叫做专用网。显然，全世界可能有很多的专用互联网络具有相同的专用IP地址，但这并不会引起麻烦，因为这些专用地址仅在本机构内部使用。专用IP地址也叫做可重用地址（reusable address）。
        有时一个很大的机构有许多部门分布在相距很远的一些地点，而在每一个地点都有自己的专用网。假定这些分布在不同地点的专用网需要进程进行通信。这时可以有两种方法。第一种是租用电信公司的通信线路为本机构专用。这种方法的好处是简单方便，但线路的租金太高。第二种方法是利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网VPN（Virtual Private Network）。
        之所以称为“专用网”是因为这种网络是为本机构的主机用于机构内部通信的，而不是用于和网络外非本机构的主机通信。如果专用网不同网点之间的通信必须经过公用的因特网，但又有保密的要求，那么所有通过因特网传送的数据都必须加密。“虚拟”表示“好像是”，但实际上并不是，因为现在并没有使用专线而是通过公用的因特网连接分散在各场所（site）的本地网络。VPN只是在效果上和真正的专用网一样。一个机构要构建自己的VPN就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的VPN系统都知道其他场所的地址。
        以两个场所为例说明如何使用IP隧道技术实现虚拟专用网。
        假定某个机构在两个相隔较远的场所建立了专用网A和B，其网络地址分别为专用地址10.1.0.0和10.2.0.0。现在这两个场所需要通过公用的因特网构成一个VPN。
        显然，每一个场所至少要有一个路由器具有合法的全球IP地址，路由器R1和R2。这两个路由器和因特网的接口地址必须是合法的全球IP地址。路由器R1和R2在和专用网内部网络的接口地址则是专用网的本地地址。
        在每一个场所A或B内部的通信量都不经过因特网。但如果场所A的主机X要和另一个场所B的主机Y通信，那么就必须经过路由器R1和R2.主机X向主机Y发送的IP数据报的源地址是10.1.0.1而目的地址是10.2.0.3。这个数据报先作为本机构的内部数据报从X发送到与因特网连接的路由器R1.路由器R1收到内部数据报后，发现其目的网络必须通过因特网才能到达，就把整个的内部数据报进行加密（这样就保证了内部数据报的安全），然后重新加上数据报的首部，封装成为在因特网上发送的外部数据报，其源地址是路由器R1的全球地址125.1.2.3，而目的地址是路由器R2的全球地址194.4.5.6。路由器R2收到数据报后将其数据部分取出进行解密，恢复出原来的背部数据报（目的地址是10.2.0.3），交付给主机Y。可见虽然X向Y发送的数据报时通过了公用的因特网，但在效果上就好像是在本部门的专用网上传送一样。如果主机Y要向X发送数据报，那么所经过的步骤也是类似的。
        请注意，数据报从R1传送到R2可能要经过因特网中的很多个网络和路由器。但从逻辑上看，在R1到R2之间好像是一条直通的点对点链路，“隧道”就是这个意思。
        场所A和B的内部网络所构成的虚拟专用网VPN又称为内联网（intranet或intranet VPN，即内联网VPN），表示场所A和B都属于同一个机构。
        有时一个机构的VPN需要有某些外部机构（通常就是合作伙伴）参加进来。这样的VPN就称为外联网（extranet或extranetVPN，即外联网VPN）。
        请注意，内联网和外联网都采用了因特网技术，即都是基于TCP/IP协议的。
        还有一种类型的VPN，就是远程接入VPN（remote access VPN）。我们知道，有的公司可能并没有分布在不同场所的部门，但却有很多流动员工在外地工作。公司需要和他们保持联系，有时还可能一起开电话会议。远程接入VPN可以满足这种需求。在外地工作的员工通过拨号接入因特网，而驻留在员工PC机中的VPN软件可以在员工的PC机和公司的主机之间建立VPN隧道，因而外地员工与公司通信的内容是保密的，员工们感觉好像就是使用公司内部的本地网络。
    4.7.2网络地址转换NAT
    下面讨论另一种情况，就是在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密），那么应当采取什么措施呢？
    最简单的办法就是设法再申请一些全球IP地址。但这在很多情况下是不容易做到的，因为全球IPv4的地址已所剩不多了。目前使用得最多的方法是采用网络地址转换。
    网络地址转换NAT（NetworkAddress Translation）方法是在1994年提出的。这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外结通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。
    NAT路由器的工作原理。专用网192.168.0.0内所有主机的IP地址都是本地IP地址192.168.x.x。NAT路由器至少要有一个全球IP地址，才能和因特网相连。（当然，NAT路由器可以有多个全球IP地址）。
    NAT路由器收到从专用网内部的主机A发往因特网上主机B的IP数据报：源IP地址是192.168.0.3，而目的地址是213.18.2.4。NAT路由器把IP数据报的源IP地址192.168.0.3，转换为新的源IP地址（即NAT路由器的全球IP地址）172.28.1.5，然后转发出去。因此，主机B收到这个IP数据报时，以为A的IP地址是172.28.1.5。当B给A发送应答时，IP数据报的目的IP地址是NAT路由器的IP地址172.28.1.5。B并不知道A的专用地址192.168.0.3。实际上，即使知道了，也不能使用，因为因特网上的路由器都不转发目的地址是专用网本地IP地址的IP数据报。当NAT路由器收到因特网上的主机B发来的IP数据报时，还要进行一次IP地址的转换。通过NAT地址转换表，就可把IP数据报上的旧的目的IP地址172.28.1.5，转换为新的目的地址192.168.0.3（主机A真正的本地IP地址）。表给出了NAT地址转换表的举例。表中的前两行数据对用于图中所举的例子。第一列“方向”中的“出”表示离开专用网，而“入”表示进入专用网。表中后两行数据表示专用网内的另一主机192.168.0.7向因特网发送了IP数据网，而NAT路由器还有另外一个全球IP地址172.28.1.6。
            NAT地址转换表举例
            方向|字段      |旧的IP地址 |新的IP地址
            出  |源IP地址  |192.168.0.3|172.28.1.5
            入  |目的IP地址|172.28.1.5 |192.168.0.3
            出  |源IP地址  |192.168.0.7|172.28.1.6
            入  |目的IP地址|172.28.1.6 |192.168.0.7
        由此可见，当NAT路由器具有n个全球IP地址时，专用网内最多可以同时有n个主机接入到因特网。这样就可以使专用网内较多数量的主机，轮流使用NAT路由器有限数量的全球IP地址。
    显然，通过NAT路由器的通信必须由专用网内的主机发起。设想因特网上的主机要发起通信，当IP数据报到达NAT路由器时，NAT路由器就不知道应当把目的IP地址转换成哪一个专用网内的本地IP地址。这就表明，专用网内部的主机不能充当服务器用，因为因特网上的客户无法请求专用网内的服务器提供服务。
    为了更加有效地利用NAT路由器上的全球IP地址，现在常用的NAT转换表把运输层的端口号也利用上。这样，就可以使多个拥有本地地址的主机，公用一个NAT路由器上的全球IP地址，因而可以同时和因特网上的不同主机进行通信。
    由于运输层的端口号将在下一章5.1.3节讨论，因此，建议在学完运输层的有关内容后，再学习下面的内容。从系统性考虑，把下面的这部分内容放在本章中介绍较为合适。
    使用端口号的NAT也叫做网络地址与端口号转换NAPT（Network Address and Port Translation）。但在许多文献中，更常用的还是使用NAT这个更加简洁的缩写词。表说明了NAPT的地址转换机制。
            NAPT地址转换表举例
            反向|字段                 |旧的IP地址和端口号 |新的IP地址和端口号
            出  |源IP地址:TCP源端口    |192.168.0.3:30000|172.28.1.5:40001
            出  |源IP地址:TCP源端口    |192.168.0.4:30000|172.28.1.5:40002
            入  |目的IP地址:TCP目的端口|172.28.1.5:40001 |192.168.0.3:30000
            入  |目的IP地址:TCP目的端口|172.28.1.5:40002 |192.168.0.4:30000
        从表可以看出，字专用网内主机192.168.0.3向因特网发送IP数据报，其TCP端口号选择为30000。NAPT把源IP地址和TCP端口号都进行转换（如果是使用UDP，则对UDP的端口号进行转换。原理是一样的）。另一台主机192.168.0.4也选择了同样的TCP端口号30000。这纯属巧合（端口号仅在本主机中才有意义）。现在NAPT把专用网内不同的源IP地址，都转换为同样的全球IP地址。但对源主机所采用的TCP端口号（不管相同或不同），则转换为不同的新的端口号。因此，当NAPT路由器收到从因特网发来的应答时，就可以从IP数据报的数据部分找出运输层的端口号，然后根据不同的目的端口号，从NAPT转换表中找到正确的目的主机。
        应当指出，从层次的角度看，NAPT的机制有些特殊。普通路由器在转发IP数据报时，对于源IP地址或目的IP地址都是不改变的。但NAT路由器在转发IP数据报时，一定要更换其IP地址（转换源IP地址或目的IP地址）。其次，普通路由器在转发分组时，是工作在网络层。但NAPT路由器还要查看和转换运输层的端口号，而这本来应当属于运输层的范畴。也正因为这样，NAPT层遭受了一些人的批评，认为NAPT的操作没有严格按照层次的关系。但不管怎样，NAT（包括NAPT）已成为因特网的一个重要构件。
        有关NAT的详细讨论见[RFC 3235,3027,3022,2993,2663]he IETF关于NAT工作组的网站。


习题
4-01    网络层向上提供的服务有哪两种？试比较其优缺点。
4-02    网络互联有何实际意义？进行网路互连时，有哪些共同的问题需要解决？
4-03    作为中间设备，转发器、网桥、路由器和网关有何区别？
4-04    试简单说明下列协议的作用：
        IP，ARP，RARP和ICMP。
4-05    IP地址分为几类？各如何表示？IP地址的主要特点是什么？
4-06    试根据IP地址的规定，计算出表4-2中的各项数据。
4-07    试说明IP地址与硬件地址的区别，为什么要使用这两种不同的地址？
4-08    IP地址方案与我国的电话号码体制的主要不同点是什么？
4-09    1）子网掩码为255.255.255.0代表什么意思？
        2）一网络的现在掩码为255.255.255.248，问该网络能够连接多少个主机？
        3）一A类网络和一B类网络的子网号subnet-id分别为16个1和8个1，问这两个网络的子网掩码有何不同？
        4）一个B类地址的子网掩码是255.255.240.0。试问在其中每一个子网上的主机数最多是多少？
        5）一A类网络的子网掩码为255.255.0.255，它是否为一个有效的子网掩码？
        6）某个IP地址的十六进制表示是C2.2F。14.81，试将其转换为点分十进制的形式。这个地址是哪一类IP地址？
        7）C类网络使用子网掩码有无实际意义？为什么？
4-10    试辨认一下IP地址的网络类别。
        1）128.36.199.3
        2）21.12.240.17
        3）183.194.76.253
        4）192.12.69.248
        5）89.3.0.1
        6）200.3.6.2
4-11    IP数据报中的首部检验和并不检验数据报中的数据。这样做的最大好处是什么？坏处是什么？
4-12    当某个路由器发现一IP数据报的教研和有差错时，为什么采取丢弃的办法而不是要求源站重传此数据报？计算首部检验和为什么不采用CRC检验码？
4-13    设IP数据报使用固定首部，其各字段的具体数值如图（除IP地址外，均为十进制表示）。试用二进制运算方法计算应当写入到首部检验的字段中的数值（用二进制表示）。
        |4|5|0  |28                     |
        |1      |0|0                    |
        |4  |17 |首部检验和（待计算后写入）|
        |10.12.14.5                     |
        |12.6.7.9                       |
4-14    重新计算上题，但使用十六进制运算方法（每16位二进制数字转换为4个十六进制数字，再按十六进制加法规则计算）。比较这两种方法。
4-15    什么是最大传送单元MTU？它和IP数据报首部中的那个字段有关系？
4-16    在因特网中将IP数据报分片传送的数据报在最后的目的主机进行组装。还可以有另一种做法，即数据报片通过一个网络就进行一次组装。试比较这两种方法的优劣。
4-17    一个3200位长的TCP报文传到IP层，加上160位的首部后成为数据报。下面的互联网由两个局域网通过路由器连接起来。但第二个局域网所能传送的最长数据帧中的数据部分只有1299位。因此数据报在路由器必须进行分片。试问第二个局域网向其上层要传送多少比特的数据（这里的“数据”当然指的是局域网看见的数据）？
4-18    1）有人认为：“ARP协议向网络层提供了转换地址的服务，因此ARP应当属于数据链路层。”这种说法为什么是错误的？
        2）试解释为什么ARP高速缓存每存入一个项目就要设置10~20分钟的超市计时器。这个时间设置得太大或太小会出现什么问题？
        3）至少举出两种不需要发送ARP请求分组的情况（即不需要请求将某个目的IP地址解析为相应的硬件地址）。
4-19    主机A发送IP数据报给主机B，途中经过了5个路由器。试问在IP数据报的发送过程中总共使用了几次ARP？
4-20    设某路由器建立了如下路由表：
        目的网络         子网掩码          下一跳
        -----------------------------------------
        128.96.39.0      255.255.255.128   接口m0
        128.96.39.128    255.255.255.128   接口m1
        128.96.40.0      255.255.255.128   R2
        192.4.153.0      255.255.255.192   R3
        *（默认）         ——                R4

        现在收到5个分组，其目的地址分别为：
        1）128.96.39.10
        2）128.96.40.12
        3）128.96.40.151
        4）192.4.153.17
        5）192.4.153.17
        试分别计算其下一跳。
4-21    某单位分配一个B类IP地址，其net-id为129.250.0.0。该单位有4000台机器，分布在16个不同的地点。如选用子网掩码为255.255.255.0，试给每一个地点分配一个子网号码，并算出每个地点主机号码的最小值和最大值。
4-22    一个数据报长度为4000字节（固定首部长度）。仙子经过一个网络传送，但此网络能够传送的最大数据长度为1500字节。试问应当划分几个短些的数据报片？各数据报片的数据字段长度、片偏移字段和MF标志应为何数值？
4-23    分两种情况（使用子网掩码和使用CIDR）写出因特网的IP层查找路由的算法。
4-24    试找出可产生以下数目的A类子网的子网掩码（采用连续掩码）。
        （1）2，（2）6，（3）30，（4）62，（5）122，（6）250。
4-25    以下有4个子网掩码。哪些是不推荐使用的？为什么
        （1）176.0.0.0，（2）96.0.0.0，（3）127.192.0.0，（4）255.128.0.0
4-26    有如下的4个/24地址块，试进行最大可能的聚合。
        212.56.132.0/24
        212.56.133.0/24
        212.56.134.0/24
        212.56.135.0/24
4-27    有两个CIDR地址块208.128/11和208.130.28/22。是否有哪一个地址块包含了另一个地址？如果有，请指出，并说明理由。
4-28    已知路由器R1的路由表
        |地址掩码|目的网络地址|下一跳地址|路由器接口|
        |/26    |140.5.12.64|180.15.2.5|m2      |
        |/24    |130.5.8.0  |190.16.6.2|m1      |
        |/16    |110.71.0.0 |------    |m0      |
        |/16    |180.15.0.0 |------    |m2      |
        |/16    |190.16.0.0 |------    |m1      |
        |默认   |默认        |110.71.4.5|m0      |
        试画出各网络和必要的路由器的连接拓扑，标注出必要的IP地址和接口。对不能确定的情况应当指明。
4-29    一个自治系统有5个局域网，其连接如图。LAN2至LAN5上的主机数分别为：91，150，3和15。该自治系统分配到的IP地址块为30.138.118/23。试给出每一个局域网的地址块（包括前缀）。
        LAN2，91个主机   LAN3，150和主机    LAN4，3个主机
        -------------    --------------    ------------
            |                    |              |
            R                    R              R--------LAN5，15个主机
            |                    |              |
        ---------------LAN1-------------------------
4-30    一个大公司有一个总部和三个下属部门。公司分配到的网络前缀是192.77.33/24。公司的网络布局如图。总部共有五个局域网，其中的LAN1~LAN4都连接到路由器R1上，R1再通过LAN5与路由器R5相连。R5和远地的三个部门的局域网LAN6~LAN8通过广域网相连。每一个局域网旁边标明的数字是局域网上的主机数。试给每一个局域网分配一个合适的网络前缀。
            LAN1，50---|                       |---R3---LAN6，20
            LAN2，10---|                       |---R4---LAN7，20
            LAN3，30---|---R1---LAN5，4---R2---|---R5---LAN8，25
            LAN4，10---|
4-31    以下地址中的哪一个和86.32/12匹配？请说明理由。
        （1）86.33.224.123；（2）86.79.64.216；（3）86.58.119.74；（4）86.68.206.154。
4-32    以下的地址前缀中的哪一个地址2.52.90.140匹配？请说明理由。
        （1）0/4；（2）32/4；（3）4/6；（4）80/4。
4-33    下面的前缀中的哪一个和地址152.7.77.159及152.31.47.252都匹配？请说明理由。
        （1）152.40/13；（2）153.40/9；（3）152.64/12；（4）152.0/11。
4-34    与下列掩码相对应的网络前缀各有多少位？
        （1）192.0.0.0；（2）240.0.0.0；（3）255.224.0.0；（4）255.255.255.252。
4-35    已知地址块中的一个地址是140.120.84.24/20。试求这个地址块中的最小地址和最大地址。地址掩码是什么？地址块中共有多少个地址？相当于多少个C类地址？
4-36    已知地址块中的一个地址是190.87.140.202/29。重新计算上题。
4-37    某单位分配到一个地址块136.23.12.64/26。现在需要进一步划分为4个一样大的子网。试问：
        1）每个字网的网络前缀有多长？
        2）每一个子网中有多少个地址？
        3）每一个子网的地址块试什么？
        4）每一个子网可分配给主机使用的最小地址和最大地址是什么？
4-38    IGP和EGP这两类协议的主要区别是什么？
4-39    试简述RIP，OSPF和BGP路由选择协议的主要特点。
4-40    RIP使用UDP，OSPF使用IP，而BGP使用TCP。这样做有何优点？为什么RIP周期性地和邻站交换路由信息而BGP却不这样做？
4-41    假定网络中的路由器B的；路由表有如下的项目（这三列分别表示“目的网络”、“距离”和“下一跳路由器”）
                N1     7     A
                N2     2     C
                N6     8     F
                N8     4     E
                N9     4     F
            现在B收到从C发来的路由信息（这两列分别表示“目的网络”和“距离”）
                N2     4
                N3     8
                N6     4
                N8     3
                N9     5
            试求出路由器B更新后的路由表（详细说明每一个步骤）
4-42    假定网络中的路由器A的路由表有如下项目（格式同上题）：
                N1     4     B
                N2     2     C
                N3     1     F
                N4     5     G
            现在A收到从C发来的路由信息（格式同上题）：
                N1     2
                N2     1
                N3     3
                N4     7
            试求出路由器A更新后的路由器（详细说明每一个步骤）。
4-43    IGMP协议的要点是什么？隧道技术是怎样使用的？
4-44    什么是VPN？VPN有什么特点和优缺点？VPN有几种类别？
4-45    什么是NAT？NAPT有哪些特点？NAT的优点和缺点有哪些？
