第3章   数据链路层
    数据链路层属于计算机网络的低层。数据链路层使用的信道主要有以下两种类型：
    1）点对点信道。这种信道使用一对一的点对点通信方式。
    2）广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。
    在这一章，我们首先介绍点对点信道和在这种信道上最常用 的点对点协议PPP。然后再用较大的篇幅讨论共享信道的局域网和有关协议。
    下面看一下两个主机通过互联网进行通信时数据链路层所处的地位。
        主机H1----路由器R1----路由器R2----路由器R3----主机H2

        ---------

        H1                                      R1                                  R2                                    R3                                     H2
        应用层--运输层--网络层--链路层--物理层-->物理层--链路层--网络层--链路层--物理层-->物理层--链路层--网络层--链路层--物理层-->物理层--链路层--网络层--链路层--物理层-->物理层--链路层--网络层--运输层--应用层

    主机H1通过电话线上网，中间经过三个路由器（R1，R2和R3）连接到远程主机H2。所经过的网络可以是多种的。如电话网、局域网和广域网。当主机H1向H2发送数据时，从协议的层次上看。主机H1和H2都有完整的五层协议栈，但路由器在转发分组时使用的协议栈只有下面的三层。数据进入路由器后要先从物理层上到网络层，在转发表中找到下一跳的地址后，再下到物理层转发出去。因此，数据从主机H1传送到主机H2需要在路径中的各结点的协议栈向上和向下流动多次。

        H1的链路层-->R1的链路层-->R2的链路层-->R3的链路层--H2的链路层

    然而当我们专门研究数据链路层的问题时，在许多情况下我们可以只关心在协议栈中水平方向的各数据链路层。于是，当主机H1向主机H2发送数据时，我们可以想象数据就是在数据链路层从左向右沿水平方向传送。
    从数据链路层来看，H1到H2的通信可以看成是由四段不同的链路层通信组成，即H1-->R1，R1-->R2，R2-->R3，R3-->H2。这四段不同的链路层可能采用不同的数据链路层协议。
3.1实用点对点信道的数据链路层
    本节讨论使用点对点信道的数据链路层的一些基本问题。其中的某些概念对广播信道也是适用的。
    3.1.1数据链路和帧
        我们在这里要明确一下，“链路”和“数据链路”并不是一回事。
        所谓链路（link）就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。在进行数据通信时，两个计算机之间的通信路径往往要经过许多这样的链路。可见链路只是一条路径的组成部分。
        数据链路（data link）则是另一个概念。这是因为当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输（这将在后面几节讨论）。若把视线这些协议的硬件和软件加到链路上，就构成了数据链路。现在最常用的方法是使用网络适配器（如拨号上网使用拨号适配器，以及通过以太网上网使用局域网适配器）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。
        也有人采用另外的术语。这就是把链路分为物理链路和逻辑链路。物理链路就是上面所说的链路，而逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。
        早期的数据通信协议曾叫做通信规程（procedure）。因此在数据链路层，规程和协议是同义语。
        下面再介绍点对点信道的数据链路层的协议数据单元--帧。
        数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。在因特网中，网络层协议数据单元就是IP数据报（或简称为数据报、分组或包）。
        为了把主要精力放在点对点信道的数据链路层协议上，可以采用三层模型。在这种三层模型中，不管在哪一段链路上的通信（主机和路由器之间或两个路由器之间），我们都看成是结点和结点的通信，而每个结点只有下三层--网络层、数据链路层和物理层。
            结点A                                           结点B
            网络层：IP数据报（↓装入）                        网络层：IP数据报
            数据链路层：帧                                  数据链路层：帧（↑取出）
            物理层--------------------链路------------------物理层
            ------------
            结点A                                              结点B
            数据链路层：帧（发送）------------链路-------------->数据链路层：帧(接收)

            点对点信道的数据链路层在进行通信时的主要步骤如下：
            1）结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。
            2）结点B把封装好的帧发送给结点B的数据链路层
            3）若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报上交给上面的网络层，否则丢弃这个帧。
        数据链路层不必考虑物理层如何实现比特传输的细节。我们甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方。
    3.1.2三个基本问题
        数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题是：封装成帧、透明传输和差错检测。下面分别讨论着三个基本问题。
        1.封装成帧
            封装成帧（framing）就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。我们知道，分组交换的一个重要概念就是：所有在因特网上传送的数据都是以分组（即IP数据报）为传送单位。网络层的IP数据报传送到数据链路层就成为帧的数据部分。在帧的数据部分的前面和后面分别添加上首部和尾部，构成了一个完整的帧。因此，帧长等于数据部分的长度加上帧首部和帧尾部的长度，而首部和尾部的一个重要作用就是进行帧定界（即确定帧的界限）。此外，首部和尾部还包括许多必要的控制信息。在发送帧时，是从帧首部开始发送。各种数据链路层协议都要对帧首部和帧尾部的格式有明确的规定。显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每一种链路层协议都规定了帧的数据部分的长度上限--最大传送单元MTU（MaximumTransferUnit）。
            当数据是由可打印的ASCII码组成的文本文件时，帧定界可以使用特殊的帧定界符。我们知道，ASCII码是7位编码，一共可组合成128个不同的ASCII码，其中可打印的有95个，而不可打印的控制字符有33个。
                帧开始符                                              帧结束符
                |SOH|           装在帧中的数据部分                     |EOT|
            控制字符SOH（StartOfHeader）放在一帧的最前面，表示帧的首部开始。另一个控制字符EOT（EndOfTransmission）表示帧的结束。请注意，SOH和 EOT都是控制字符的名称。它们的十六进制编码分别是01（二进制是00000001）和04（二进制是00000100）。SOH（或EOT）并不是S，O，H（或E，O，T）三个字符。
            当数据在传输中出现差错时，帧定界符的作用更加明显。假定发送端在尚未发送完一个帧时突然出故障，中断了发送。但随后很快又恢复正常，于是重新从开头开始发送刚才未发送完的帧。由于使用了帧定界符，在接收端就知道前面收到的数据是个不完整的帧（只有首部开始符SOH而没有传输结束符EOT），必须丢弃。而后面收到的数据有明确的帧定界符（SOH和EOT），因此这是一个完整的帧，应当收下。
        2.透明传输
            由于帧的开始和结束的标记是使用专门指明的控制字符，因此，所传输的数据中的任何8比特的组合一定不允许和用作帧定界的控制字符和比特编码一样。否则就会出现帧定界的错误。
            当传送的帧是用文本文件组成的帧时（文本文件中的字符都是从键盘上输入的），其数据部分显然不会出现想SOH或EOT这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。
            但当数据部分是非ASCII码的文本文件时（如二进制代码的计算机程序的计算机程序或图像等），情况就不同了。如果数据中的某个字节的二进制代码恰好和SOH或EOT这种控制字符一样，数据链路层就会错误地“找到帧的边界”，把部分帧收下（误认为是个完整的帧），而把剩下的那部分数据丢弃（这部分找不到帧定界控制字符SOH）。
            为了解决透明传输问题，就必须设法使数据中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符。具体的方法是：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”（其十六进制编码是1B）。而在接收端的数据链路层在将数据送往网络层之间删除这个插入的转义字符。这种方法称为字节填充（byte stuffing）或字符填充（character stuffing）。如果转义字符也出现数据当中，那么结局方法仍然是在转义字符的前面插入一个转义字符。因此当接收端收到连续的两个转义字符时，就删除其中前面的一个。
        3.错检测
            现实的通信链路都不会是理想的。这就是说，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1.这就叫做比特差错。比特差错是传输差错中的一种。本小节所说的“差错”，如无特殊说明，就是指“比特差错”。在一段时间内，传输错误的比特占所传输比特总数的比率肠胃误码率BER（BitErrorRate）。例如，误码率为10^-10时，表示平均每传送10^10个比特就会出现的差错。误码率与信噪比有很大的关系。如果设法提高信噪比，就可以使误码率减小。实际的通信链路并非理想的，它不可能使误码率下降到零。因此为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。目前在数据链路层广泛使用了循环冗余检测CRC（Cyclic Redundancy Check）的检错技术。
            下面我们通过一个简单的例子来说明循环冗余检验的原理。
                在发送端，先把数据划分为组，假定每组k个比特。现假定待发送的数据M=101001（k=6）。CRC运算就是在数据M的后面添加供差错检测用的n为冗余码，然后构成一个帧发送出去，一共发送（k+n）位。在所要发送的数据后面增加n位冗余码，虽然增大了数据传输的开销，但却可以进行差错检测。当传输可能出现差错时，付出这种代价往往是很值得的。
                这n位冗余码可用以下方法得出。用二进制的模2运算进行2^n乘M的运算，这相当于在M后面添加n个0。得到的（k+n）位的数除以收发双方事先商定的长度为（n+1）位的除数P，得出商是Q而余数是R（n位，比P少一位）。关于除数P下面还要介绍。在例子中，M=101001（即k=6）。假定除数P=1101（即n=3）。经模2除法运算后的结果是：商Q=110101（这个商并没有什么用处），而余数R=001.这个余数R就作为冗余码拼接在数据M的后面发送出去。这种为了进行检错而添加的冗余码常称为帧检验序列FCS（FrameCHecjSequence）。因此加上FCS后发送的帧是101001001（即2^nM+FCS），共有（k+n）位。
                顺片说一下，循环冗余检验CRC和帧检验序列FCS并不是同一个概念。CRC是一种检错方法，而FCS是添加在数据后面的冗余码，在检错方法上可以选用CRC，也可不选用CRC。
                在接收端把接收到的数据以帧为单位进行CRC检验：把收到的每一个帧都除以同样的除数P（模2运算），然后检查得到的余数R。
                如果在传输过程中无差错，那么经过CRC检验后得出的余数R肯定是0。
                但如果出现误码，那么袁术R仍然等于零的概率非常非常小的。
                总之，在接收端对收到的每一帧经过CRC检验后，
                1）若得出的余数R=0，则判定这个帧没有差错，就接受（accept）。
                2）若余数R！=0，则判定这个帧有差错（但无法确定究竟是哪一位或哪几位出现了差错），就丢弃。
                一种较方便的方法是用多项式来表示循环冗余检验过程。在上面的例子中，用多项式P（X）=X^3+X^2+1表示上面的除数P=1101（最高位对应于X^3，最低位对应于X^0）。多项式P（X）称为生成多项式。现在广泛使用的生成多项式P（X）有以下几种：
                    CRC-16=X^16+X^15+X^2+1
                    CRC-CCITT=X^16+X^12+X^5+1
                    CRC-32=X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X+1
                在数据链路层，发送端帧检测序列FCS的生成和接收端的CRC检验都是用硬件完成的，处理很迅速，因此并不会延误数据的传输。
                从以上的讨论不难看出，如果我们在传送数据时不以帧为单位来传送，那么就无法加入冗余码以进行差错检验。因此，如果要在数据链路层进行差错检验，就必须把数据划分为帧，每一帧都加上冗余码，一帧接一帧地传送，然后在接收方逐渐进行差错检验。
                最后再强调一下，在数据链路层若仅仅使用循环冗余检验CRC差错检测技术，则只能做到对帧的无差错接受。即“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。接收端丢弃的帧虽然曾收到了，但最终还是因为有差错被丢弃，即没有被接受。以上所述的可以近似地表述为（通常都是这样认为）：“凡是接收端数据链路层接受的帧均无差错”。
                请注意，我们现在并没有要求数据链路层向网络层提供“可靠传输”的服务。所谓“可靠传输”就是：数据链路层的发送端发送什么，在接收端就收到什么。传输差错可分为两大类：一类就是前面所说的最基本的比特差错，而另一类传输差错则更复杂些，这就是收到的帧并没有出现比特差错，但却出现了帧丢失、镇重复或帧失序。例如。发送方连续传送三个帧【#1】-【#2】-【#3】。假定在接收端收到的却有可能出现下面的情况：
                    帧丢失：收到【#1】-【#3】（丢失【#2】）
                    帧重复：收到【#1】-【#2】-【#2】-【#3】（收到两个【#2】）。
                    帧失序：收到【#1】-【#3】-【#2】
                以上三种情况都属于“出现传输差错”，但都不是这些帧里有“比特差错”。帧丢失很容易理解。但出现帧重复和帧失序的情况则较为复杂，对这些问题我们现在不展开讨论。在学完第5章的5.4节后，我们就会知道什么情况下接收端可能会出现帧重复或帧失序。
                总之，我们应当明确，“无比特差错”与“无传输差错”并不是同样的概念。在数据链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。
                我们知道，OSI的观点是必须把数据链路层做成是可靠传输的。因此在CRC检错的基础上，层架了帧编号、确认和重传机制。收到正确的帧就要向发送确认。发送端在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，知道收到对方的确认为止。这种方法在历史上曾经起到很好的作用。但现在的通信线路的质量已经大大提高了，有通信链路质量不好引起的差错的概率已经大大降低。因此，因特网广泛使用的数据链路层协议都不使用确认和重传机制，即不要求数据链路层向上提供可靠传输的服务（因为这要付出的代价太高，不合算）。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议（例如，运输层的TCP协议）来完成。实践证明，这样做可以提高通信的效率。
                本教材的前几个版本中曾采用以前OSI的思路，在数据链路层讲述可靠传输的原理（例如停止等待协议和滑动窗口机制）。但由于现在实际的有线网络的数据链路层已很少采用可靠传输，因此我们就把确认和重传机制改在后面第5章运输层TCP中讨论。这样作比较符合因特网现在的实际情况。
3.2点对点协议PPP
    在通信线路质量较差的年代，在数据链路层使用可靠传输协议曾经是一种好办法。因此，能实现可靠传输的高级数据链路控制HDLC（High-level Data Link Control）就成为当时比较流行的数据链路协议。但现在HDLC已很少使用了。对于点对点的链路，简单得多的点对点协议PPP（Point-to-Point Protocol）则是目前使用得最广泛的数据链路层。
    3.2.1PPP协议的特点
        我们知道，因特网用户通常都要连接到某个ISP才能接入到因特网。PPP协议就是用户计算机和ISP进行通信时所使用的数据链路层协议。
        PPP协议是IETF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议在1994年就已成为因特网的正式标准。
        1.PPP协议应满足的需求
            IETF认为，在设计PPP协议时必须考虑以下多方面的需求：
                1）简单    IETF在设计因特网体系结构时把其中最复杂的部分放在TCP协议中，而网际协议IP则相对比较简单，它提供的是不可靠的数据报服务。在这种情况下，数据链路层没有必要提供比IP协议更多的功能。因此，对数据链路层的帧，不需要纠错，不需要序号，也不需要流量控制。当然，在误码率较高的无线链路上可能会需要更为复杂的链路层协议。因此IETF把“简单”作为首要的需求。
                          简单的设计还可使协议在实现时不容易出错，因而使得不同厂商对协议的不同实现的互操作性提高了。我们知道，协议标准化的一个主要目的就是提高协议的互操作性。
                          总之，这种数据链路层的协议非常简单：接收方每收到一个帧，就进行CRC检验，如CRC检验正确，就收下这个帧，反之，就丢弃这个帧，其他什么也不做。
                2）封装成帧      PPP协议必须规定特殊字符作为帧定界符（即标志一个帧的开始和结束的字符），以便使接收端从收到的比特流中能准确地找出帧的开始和结束的位置。
                3）透明性   PPP协议必须保证数据传输的透明性。这就是说，如果数据中碰巧出现了和帧定界符一样的比特组合时，就要采取有效措施来解决这个问题。
                4）多种网络层协议   PPP协议必须能够在在同一条物理链路上同时支持多种网络层协议（如IP和IPX等）的运行。当点对点链路所连接的是局域网或路由器时，PPP协议必须同时支持在链路所连接的局域网或路由器上运行的各种网络层协议。
                5）多种类型链路    除了要支持多种网络层的协议外，PPP还必须能够在多种类的链路上运行。例如，串行的（一次只发送一个比特）或并行的（一次并行地发送多个比特），同步的或异步的，低俗的或高速的，电的或光的，交换的（动态的）或非交换的（静态的）点对点链路。
                    这里特别要提到的是在1999年公布的在以太网上运行的PPP，即PPP over Ethernet，简称为PPPoE，这是PPP协议能够适应多种类型链路的一个典型例子。PPPoE是为宽带上网的主机使用的链路层协议。这个协议把PPP帧再封装在以太网帧中（当然还要增加一些能后识别各用户的功能）。宽带上网时由于数据传输速率较高，因此可以让多个连接在以太网上的用户共享一条道ISP的宽带链路。现在，即使是只有一个用户利用ADSL进行宽带上网（并不和其他人共享到ISP的宽带链路），也是使用PPPoE协议。
                6）差错检测（error detection）   PPP协议必须能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。若在数据链路层不进行差错检测，那么已出现差错的无用帧就还要在网络中继续向前转发，因而会白白浪费许多的网络资源。
                7）检测连接状态    PPP协议必须具有一种机制能够及时（不超过几分钟）自动检测出链路是否处于正常工作状态。当出现故障的链路隔一段时间后又重新恢复正常工作时，就特别需要有有这种及时检测功能。
